[{"categories":null,"content":"일반 거래란 무엇인가요? 이더리움 블록체인 에서의 일반적인 거래는 두 지갑 주소 간의 이더(ETH) 또는 토큰 의 간단한 전송을 말합니다.\n이러한 거래는 사용자가 시작하고 블록체인 에 직접 기록되므로 쉽게 추적할 수 있습니다.\n특징 사용자가 시작함: 일반적인 거래는 일반적으로 개인이나 단체가 한 주소에서 다른 주소로 ETH 또는 토큰을 보내면서 시작됩니다.\n블록체인에 기록됨: 모든 일반적인 거래는 이더리움 블록체인에 영구적으로 기록되어 투명하고 변경 불가능한 기록을 제공합니다.\n거래 수수료: 사용자는 거래를 처리하고 확인하기 위해 채굴자에게 가스 수수료를 지불해야 합니다. 수수료는 네트워크 혼잡과 거래의 복잡성에 따라 다릅니다.\n간단한 구조: 일반적인 거래에는 보내는 사람과 받는 사람의 주소, 이체 금액, 가스 한도 등의 기본 정보가 포함됩니다.\n가시성: 이러한 거래는 Etherscan에 있는 모든 사람이 볼 수 있으므로 사용자는 이체를 추적하고 잔액을 확인할 수 있습니다.\n일반적인 거래는 어떻게 이루어지나요? 거래 생성: 사용자는 수신자 주소와 지갑 앱에서 보낼 이더(ETH) 또는 토큰의 양을 지정합니다.\n거래 서명: 거래는 발신자의 개인 키로 서명되어 진위 여부를 검증합니다.\n거래 브로드캐스팅: 서명된 거래는 검증을 위해 이더리움 네트워크로 전송됩니다.\n거래 풀: 거래는 채굴자들이 다음 블록에 포함할 거래를 선택하는 메모풀 에 들어갑니다.\n채굴 및 확인: 채굴자는 암호화 퍼즐을 풀어 거래가 포함된 블록을 블록체인에 추가합니다.\n확정성: 거래가 확인되면 블록체인에 기록되어 수신자의 잔액이 업데이트됩니다.\n가스 요금: 보내는 사람은 거래 복잡성과 네트워크 혼잡도에 따라 가스 요금을 지불합니다.\n일반 거래에 대한 사용 사례 P2P 전송: 개인 간에 ETH나 토큰을 보내는 것.\n상품 및 서비스에 대한 지불: 암호화폐를 사용하여 구매합니다.\n자금 지갑: 거래 또는 투자 목적으로 다른 지갑으로 자산을 이전하는 것입니다.\n일반 거래를 보려면 어떻게 해야 하나요? Etherscan 방문 : etherscan.io 로 가세요 .\n주소 검색 : 검색창에 지갑 주소를 입력하세요.\n주소 페이지에 접속하세요 . 검색 결과에서 주소를 클릭하세요.\n거래 탭으로 이동합니다 . \u0026ldquo;거래\u0026rdquo; 탭을 클릭하면 모든 일반 거래 목록이 표시됩니다.\n검토 세부 정보 : 각 거래에는 거래 해시, 보낸 사람 및 받는 사람 주소, 값, 거래 수수료 및 타임스탬프가 표시됩니다.\n내부 거래란 무엇인가요? 내부 거래는 \u0026ldquo;메시지 호출\u0026rdquo; 또는 \u0026ldquo;계약 상호작용\u0026quot;이라고도 하며, 이더리움 블록체인의 스마트 계약 내에서 발생합니다.\n지갑 주소 간에 이더나 토큰을 직접 전송하는 일반적인 거래와 달리, 내부 거래는 스마트 계약 내에서 코드를 실행한 결과로 발생합니다.\n특징 스마트 계약에 의해 트리거됨: 스마트 계약이 다른 스마트 계약을 호출하거나 실행 중에 계약에 Ether를 보낼 때 내부 거래가 생성됩니다 .\n블록체인에 직접 기록되지 않음: 내부 거래는 정상적인 거래가 시작된 시점까지 추적이 가능하지만, 자체 거래 해시가 없으며 일반적인 거래처럼 블록체인에 명시적으로 기록되지 않습니다.\n복잡한 논리: 내부 거래에는 토큰 전송, 다중 서명 작업, 계약 조건에 따라 트리거되는 자동화 기능 등 복잡한 논리가 포함되는 경우가 많습니다.\nEtherscan에서의 가시성: 주요 거래 목록에는 표시되지 않지만 내부 거래는 특정 계약 또는 지갑의 \u0026ldquo;내부 거래\u0026rdquo; 탭에서 Etherscan에서 볼 수 있습니다.\n사례 사용: 내부 거래는 일반적으로 분산 애플리케이션(dApp) , 분산 금융(DeFi) 프로토콜에서 사용되며 복잡한 계약 상호작용을 실행하는 데 사용됩니다.\n내부 거래는 어떻게 이루어지나요? 이벤트 발생: 스마트 계약이 실행되면 내부 거래가 시작되며, 이는 대개 정상적인 거래에 대한 응답으로 시작됩니다.\n계약 상호작용: 스마트 계약은 실행되는 동안 다른 계약을 호출하거나 논리의 일부로 Ether를 주소로 보낼 수 있습니다.\n별도의 거래 해시 없음: 내부 거래에는 고유한 거래 해시가 없으며 원래의 일반 거래에 연결됩니다.\n실행 로직: 내부 전송은 스마트 계약 코드의 일부로 발생하며, 여기에는 토큰 전송이나 다중 서명 승인과 같은 복잡한 작업이 포함될 수 있습니다.\n가시성: 주요 거래 목록에서는 보이지 않지만 내부 거래는 관련 계약 또는 지갑과 관련된 Etherscan의 \u0026ldquo;내부 거래\u0026rdquo; 탭에서 볼 수 있습니다.\n내부 거래에 대한 사용 사례 분산형 금융(DeFi): 프로토콜 내에서 대출, 차용 및 유동성 공급을 자동화합니다.\n토큰 스왑: 분산형 거래소(DEX)의 유동성 풀 간 자산 이전을 관리합니다.\n자동화된 시장 조작자(AMM): 내부적인 움직임을 통해 공급과 수요에 따라 토큰 가격을 조정합니다.\n크라우드 펀딩 및 ICO: 기금 모금 이벤트 중에 자금 분배 및 토큰 할당을 투명하게 처리합니다.\n게임과 NFT: 플레이어 간에 게임 내 자산과 NFT를 쉽게 전송할 수 있습니다.\n내부 거래를 보는 방법? Etherscan 방문 : etherscan.io 로 가세요 .\n주소 또는 거래 검색 : 검색 창에 지갑 주소나 거래 해시를 입력하세요.\n주소 또는 거래 페이지에 접속하세요 . 해당 결과를 클릭하면 전용 페이지가 열립니다.\n\u0026ldquo;내부 거래\u0026rdquo; 탭으로 이동합니다 . 주소 또는 거래 페이지에서 \u0026ldquo;내부 거래\u0026rdquo; 탭을 찾으세요.\n검토 세부 정보 : 보낸 사람, 받는 사람, 가치 및 관련된 일반 거래와 같은 세부 정보를 포함한 내부 거래 목록을 확인합니다.\n일반 거래 vs 내부 거래 다음 표는 Etherscan의 일반 트랜잭션과 내부 트랜잭션의 차이점을 나타냅니다.\n구분 일반 거래 내부 거래 정의 지갑 간 ETH나 토큰을 직접 전송합니다. 스마트 계약 실행 중 발생하는 전송. 개시 사용자 작업(예: ETH 보내기)에 의해 트리거됩니다. 스마트 계약 실행이나 상호작용을 통해 발생합니다. 시계 블록체인과 Etherscan에서 쉽게 볼 수 있습니다. 독립된 항목으로 직접 기록되지 않음; 별도 탭에서 확인 가능. 거래 해시 각 거래에는 고유한 거래 해시가 있습니다. 고유한 거래 해시가 없으며, 정상적인 거래를 시작하는 데 연결됩니다. 가스 요금 발신자가 가스 요금을 지불해야 합니다. 일반적으로 초기 거래의 가스 요금에 포함됩니다. 사용 사례 피어투피어(Peer-to-Peer) 전송, 지불 및 토큰 전송. DeFi 운영, 토큰 스왑, 게임 거래 및 계약 상호 작용. 복잡성 일반적으로 단순합니다. 복잡한 논리와 자동화된 프로세스가 포함될 수 있습니다. 기록 이더리움 블록체인에 직접 기록됩니다. 스마트 계약 실행 중의 맥락에서 기록됩니다. Reference\nhttps://www.geeksforgeeks.org/normal-transactions-vs-internal-transactions-in-etherscan/ ","permalink":"https://findmytrueself.github.io/ko/blockchain/internaltx/","tags":["Blockchain","Ethereum"],"title":"일반 거래와 내부 거래(Internal Tx)"},{"categories":null,"content":"약수 : 어떤 정수를 나머지 없이 나눌 수 있는 정수\n모든 수를 나눠서 약수 구하기 조건 : 나누었을때 나머지의 값이 0이면 추가\n조건을 만족 못했을때는 추가\n조건 범위 : 약수는 최대 자기 자신까지 되기 때문에 반복문에서 자기 자신 값 이하로 설정\nlet num = 8; // 약수를 찾기 위한 정수 설정 let result = [] let index = 1; while (index \u0026lt;= num) { if (num % index === 0) result.push(index) index++ } console.log(result) // [ 1, 2, 4, 8 ] 주어진 수의 절반을 대상으로만 확인하기 약수는 본인을 제외하고 num/2 보다 클 수 없기 때문에 절반 값 까지만 체크\nlet num = 8; let result = [] let index = 1; while (index \u0026lt;= num / 2) { if (num % index === 0) result.push(index) index++ } result = [...result, num] // 본인 값 추가까지 추가 console.log(result) // [ 1, 2, 4, 8 ] 제곱근(Math.sqrt) 사용하기 1 ~ num의 제곱근 범위로 num의 약수 구해\nnum이 100이면 1~10 까지 나눠서 나머지가 0 인 값 구한다.\n[1, 2, 4, 5, 10]\nnum을 위의 약수로 나누었을때 값 역시 num의 약수\n100 / 1 = 100\n100 / 2 = 50\n100 / 4 = 25\n100 / 5 = 20\n100 / 10 = 10 → 중복\n[1, 2, 4, 5, 10, 10, 20, 25, 50, 100]\n중복제거\nnum / 1번의 약수 === 1번의 약수 인거 제외\n[1, 2, 4, 5, 10, 20, 25, 50, 100]\nSet 이용\nlet num = 100; let result = [] let index = 1; while (index \u0026lt;= Math.sqrt(num)) { if (num % index === 0) { result.push(index) if (num / index !== index) result.push(num / index) } index++ } result.sort((a, b) =\u0026gt; a - b) console.log(result) // [ 1, 2, 4, 5, 10, 20, 25, 50, 100 ] Reference\nhttps://velog.io/@woody_/JS-%EC%95%BD%EC%88%98-%EA%B5%AC%ED%95%98%EA%B8%B0-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98 ","permalink":"https://findmytrueself.github.io/ko/algorithm/%EC%95%BD%EC%88%98%EA%B5%AC%ED%95%98%EA%B8%B0/","tags":["Algorithm","Javascript"],"title":"약수 구하기"},{"categories":null,"content":"3년차 Web3 프론트엔드 개발자 - 임훈 Experience Web3 Frontend Developer Aergo | 2023.01 – present\n아르고 블록체인에서 운영 중인 프론트엔드 오픈소스 기능 개발 및 유지 보수를 담당.\nAergo Connect 3.0 크롬익스텐션 개인지갑 개발 및 배포 ( 📎 배포 | 깃헙 )\nManifest2 → Manifest3 마이그레이션\nMulti Accounts 관리 및 Private Network 기능 추가\nHardware Wallet Nano Ledger 기능 추가\n#Typescript #Vuejs #Vuex #Chrome Extension #Manifest3 #IndexedDb #ServiceWorker\nAergo Scan UI 개선 및 개발자 인터렉티브(Read \u0026amp; Write) 기능 개발 ( 📎 배포 | 깃헙 )\n스캐너에서 스마트 컨트랙트를 통해 사용자가 직접 트랜잭션을 실행하고 컨트랙트 데이터를 조회할 수 있는 기능 구현\nInternal Tx 조회 기능 추가 및 원본 source code 조회 기능 추가\n#Typescript #Vuejs #Vuex\nAergo Bridge 아르고, 이더리움 브릿지 서비스와 어드민 개발 및 배포 ( 📎 배포 )\n- 오픈 4개월만에, 500만개 이상의 아르고 to 이더리움 브릿징 성공 (2024.09.13 기준)\n#Next.js(v14) #react-hook-form #react-query #wagmi\nAergo SDK(Hera.js) GRPC → GRPC JS 마이그레이션 ( 📎 깃헙 )\n- SDK가 최신 Node.js 버전과 호환되도록 업데이트\nFrontend Developer Blocko | 2022.01 – present\nWeb3 담당 및 서비스 UI 개발과 백엔드 API 연동\nGEMVERSE - 앱토스 지갑 연동 및 개인 서명 기능 추가\n서명 시, Serialize를 하여, 백엔드로 안전히 서명 전달하는 기능 구현 Aergo Enterprise Manager (기업용 프라이빗 블록체인) - 기능 개선 및 버그 수정\n체인, 노드 편집 기능 버그를 수정하고, 데이터를 최신 상태로 동기화 Projects • Road To Interview (21년 11월~4주)\n개발자 기술면접 준비를 위해 스스로 연습할 수 있는 웹앱 ( 📎 깃헙 | 기획서 )\n[프론트엔드] Javascript, React, Emotion, Redux\n[클라이언트배포] AWS(S3, Route53, Certificate Manager, CodePipeline, CloudFront)\nWebRTC API를 이용하여, 영상 인터뷰페이지를 제작 서버 크롤링 데이터를 이용하여, 개발자 구직공고 페이지 제작 클라이언트 자동배포 및 PWA배포 설정 Education 코드스테이츠\n소프트웨어 엔지니어링 부트캠프 IM 29 수료\n2021.04 – 2021.11\n중국전매대학(Communication University of China)\n미디어 커뮤니케이션 학사 졸업\n2015 – 2019\nSkills • Javascript\n• Typescript\n• React.js\n• Next.js\n• Web 3 (Blockchain)\n• Vue.js\nLanguages • Korean - Native\n• English - C1(ESL)\n• Chinese - HSK6\nContributions 저는 Aergo 팀의 일원으로서 Aergo 오픈 소스 프로젝트에 기여하고 있습니다. 3년 차 프론트엔드 개발자로서 React 생태계에서 개발을 하고 있습니다. ","permalink":"https://findmytrueself.github.io/ko/posts/about-me/","tags":null,"title":"ABOUT ME"},{"categories":null,"content":"function solution(s) { const obj = {\u0026#39;zero\u0026#39;:0, \u0026#39;one\u0026#39;:1, \u0026#39;two\u0026#39;:2, \u0026#39;three\u0026#39;:3, \u0026#39;four\u0026#39;:4, \u0026#39;five\u0026#39;:5, \u0026#39;six\u0026#39;:6, \u0026#39;seven\u0026#39;:7, \u0026#39;eight\u0026#39;:8, \u0026#39;nine\u0026#39;:9} let stringNum = \u0026#39;\u0026#39; let answer = \u0026#39;\u0026#39; for(let i=0; i\u0026lt;s.length; i++){ let temp = +s[i] if(isNaN(temp)){ stringNum += s[i] if(obj[stringNum] || obj[stringNum] === 0){ // 반례 \u0026#39;one0zero0\u0026#39; 0은 falsy한 값이기 때문에 값을 정확하게 써줘야 한다. answer += obj[stringNum] stringNum = \u0026#39;\u0026#39; } } else { answer += s[i] } } return +answer } ","permalink":"https://findmytrueself.github.io/ko/algorithm/%EC%88%AB%EC%9E%90-%EB%AC%B8%EC%9E%90%EC%97%B4%EA%B3%BC-%EC%98%81%EB%8B%A8%EC%96%B4lv1/","tags":["Algorithm","Javascript"],"title":"숫자 문자열과 영단어(LV1)"},{"categories":null,"content":"function getCombinations(arr, selectNumber) { const results = []; if (selectNumber === 1) { return arr.map((value) =\u0026gt; [value]); // 하나씩 반환 } arr.forEach((fixed, index, array) =\u0026gt; { const rest = array.slice(index + 1); // 현재 요소 이후의 배열 const combinations = getCombinations(rest, selectNumber - 1); // 재귀 호출 const attached = combinations.map((combination) =\u0026gt; [fixed, ...combination]); // 현재 요소와 조합을 붙임 results.push(...attached); }); return results; } ","permalink":"https://findmytrueself.github.io/ko/algorithm/%EC%A1%B0%ED%95%A9combinations/","tags":["Algorithm","Javascript"],"title":"조합(Combinations)"},{"categories":null,"content":"가고 싶은 회사 라이브 코딩테스트에서 이 문제가 그대로 나왔다.\n3년 전, 신입 준비 할 때 코딩테스트 준비 하면서 분명히 풀어봤던 문젠데\u0026hellip; 오래 되어서 기억이 나질 않았다.\n중간에 못푼게, 너무 아쉬웠다. 그래서 복기를 해보는 중이다.\nfunction solution(s) { let stack = []; let obj = { \u0026#39;(\u0026#39;: \u0026#39;)\u0026#39;, \u0026#39;{\u0026#39;:\u0026#39;}\u0026#39;, \u0026#39;[\u0026#39;:\u0026#39;]\u0026#39; }; for (let i = 0; i \u0026lt; s.length; i++) { if (Object.keys(obj).includes(s[i])) { stack.push(s[i]); // 좌측의 괄호만 stack에 넣는다. } else { let last = stack.pop(); // stack 배열의 가장 마지막을 빼서 if (s[i] !== obj[last]) { // 올바른 괄호에 맞춰보고, 아니면 false return false; } } } if (stack.length !== 0) { // stack에 어떤 값이 남아 있다면, 괄호가 모두 닫히지 않았다는 의미가 된다. 고로, false return false; } else { return true; // stack이 모두 제거가 되었다는 뜻은, 괄호가 모두 올바르게 닫혔다는 의미, 고로 true } } ","permalink":"https://findmytrueself.github.io/ko/algorithm/%EC%98%AC%EB%B0%94%EB%A5%B8%EA%B4%84%ED%98%B8/","tags":["Javascript","Algorithm"],"title":"올바른 괄호 (LV2)"},{"categories":null,"content":"기업에서 사용 될 이더리움 기반 프라이빗 블록체인 대표적으로 Hyperledger Besu에 대해 알아보자.\n먼저, 의문점이 있다. 블록체인이란 기본적인 컨셉은 퍼블릭한 투명성을 목표로 탈중앙화가 목표인데, 프라이빗이란 개념이 들어간다는건, 블록체인의 컨셉에 어긋나는게 아닌가?\n프라이빗 블록체인의 기본적인 컨셉은 기업이나 개인 환경에서 사용이다.\n한마디로, 구축자의 특성에 맞는 또 다른 이더리움 세계를 구축한다는 것이다.\n어떤 환경 내에서도 불변성, 투명성이 필요하다. 그래서 특정 환경일때, DB를 사용하지 않고, 이러한 장점이 있는 프라이빗 블록체인을 사용한다.\nHyperledger Besu Besu는 EVM을 지원하는 오픈소스이다. 자체 네트워크를 구성 할 수 있는 프라이빗 블록체인 및 이더리움과 연동가능한 퍼블릭 네트워크 구성까지 가능하다.\n아래 그림은 합의 알고리즘에 대한 비교이다. Besu 프라이빗 네트워크 구성도 퍼블릭 이더리움과 연결 되지 않는 독립적인 네트워크를 구성하여, 거래의 프라이버시를 유지 및 트랜잭션 처리를 한다. 주로 QBFT, IBFT2.0, Clique 등의 합의 알고리즘을 사용한다. 합의 알고리즘 비교\nQBFT(Quorum Byzantine Fault Tolerance): 컨센시스가 J.P. Morgan과 협력하여 개발한 합의 알고리즘으로 기존 IBFT합의 알고리즘을 확장한 것으로, 기업 사용 사례에 맞게 개선된 기능을 제공한다.\nIBFT (Istanbul Byzantine Fault Tolerance): IBFT는 기존 블록체인에 PBFT(Practical Byzantine Fault Tolerance)를 적용할 때 발생하는 몇 가지 문제를 해결한 것으로 거래의 Finality를 보장하였다.\nCliquePoA: 기존 go-ethereum에 포함된 기본 PoA(Proof of Authority)합의 알고리즘이다.\nRaft기반 합의: 빠른 블록 시간, 거래 종결성(Finality), 수요에 따른 블록 생성을 위한 합의 알고리즘이다.\n권한 제어\n노드 권한 제어: 각 노드의 네트워크 참여 여부.\n계정 권한 제어: 각 계정의 트랜잭션 혹은 컨트랙트 생성 여부\nBesu 퍼블릭 네트워크 구성도 퍼블릭 이더리움과 연동이 가능하고, 이더리움의 실행 클라이언트를 담당한다. 이번 이더리움 Merge 마이그레이션 이후, 합의클라이언트와 실행클라이언트로 나뉘게 된다. Besu 또한 실행 클라이언트 기능을 한다. 주로 Teku 합의 클라이언트를 사용한다. Reference\nhttps://usa.visa.com/solutions/crypto/enterprise-blockchain.html https://blog.web3labs.com/a-comparison-of-ethereum-clients https://blog.web3labs.com/web3development/comparing-byzantine-fault-tolerance-consensus-algorithms https://www.hyperledger.org/blog/why-hyperledger-besu-is-a-top-choice-for-financial-use-cases 하이퍼레저 베수와 쿼럼의 Use cases\nLACChain RTI Blockchain Poste Italiane Onyx Digital Assets Synaptic Health Alliance ","permalink":"https://findmytrueself.github.io/ko/blockchain/besu/","tags":["Blockchain","Ethereum"],"title":"Ethereum Private Blockchain with Besu"},{"categories":null,"content":"주요 합의 알고리즘 종류 작업 증명 (Proof of Work, PoW) 네트워크 참여자들이 매우 복잡한 수학적 문제를 해결하는 경쟁을 통해 블록을 생성하는 방식입니다. 이 문제를 먼저 해결한 노드가 새로운 블록을 추가할 권리를 얻게 됩니다. 예시: 비트코인, 이더리움(2.0 이전). 장점: 보안성이 높고, 중앙화된 권한 없이 탈중앙화된 네트워크에서 동작 가능. 단점: 에너지 소모가 매우 크고, 처리 속도가 느릴 수 있음. 지분 증명 (Proof of Stake, PoS) 설명: 노드가 보유한 암호화폐의 양(지분)에 따라 블록 생성 권한을 얻는 방식입니다. 지분이 많을수록 새로운 블록을 추가할 확률이 높아집니다. 예시: 이더리움(2.0), 카르다노(Cardano), 폴카닷(Polkadot). 장점: 에너지 효율이 높고, PoW에 비해 블록 생성 속도가 빠름. 단점: 지분이 많은 노드에 의한 중앙화 가능성. 위임 지분 증명 (Delegated Proof of Stake, DPoS) 설명: 사용자가 일정 수의 대표자를 선출하고, 이 대표자들이 블록을 생성하는 방식입니다. 대표자는 네트워크 참여자들의 투표에 의해 선정되며, 이들이 블록 검증과 생성 작업을 수행합니다. 예시: EOS, 트론(Tron), 스팀(Steem). 장점: PoS에 비해 더 빠른 처리 속도를 제공하며, 에너지 효율이 좋음. 단점: 선출된 소수의 노드에 의해 중앙화될 가능성이 있음. 권한 증명 (Proof of Authority, PoA) 설명: 신뢰할 수 있는 소수의 검증자가 블록을 생성하는 방식입니다. 검증자는 네트워크 내에서 신뢰할 수 있는 인물로 인증된 상태여야 하며, 이들이 블록을 추가하는 역할을 합니다. 예시: VeChain, 일부 프라이빗 블록체인. 장점: 매우 빠르고, 신뢰할 수 있는 환경에서 효율적으로 동작. 단점: 중앙화되어 있을 가능성이 높고, 소수의 검증자에게 의존. 지연된 작업 증명 (Delayed Proof of Work, dPoW) 설명: 블록체인의 보안을 강화하기 위해 기존 PoW 블록체인의 해시를 사용하여 추가 보안 레이어를 제공하는 방식입니다. 즉, 보조 체인이 주요 PoW 체인의 보안을 빌려와 활용하는 형태입니다. 예시: Komodo. 장점: 기존 PoW 블록체인의 보안성을 활용하면서도 효율성을 높임. 단점: 기존 PoW 체인에 의존성이 있음. 비잔틴 장애 허용 (Byzantine Fault Tolerance, BFT) 설명: 비잔틴 장군 문제를 해결하기 위한 방식으로, 네트워크 내 일부 노드가 악의적인 행위를 하거나 응답하지 않는 상황에서도 시스템이 정상적으로 동작할 수 있게 합니다. 예시: Hyperledger, Tendermint. 장점: 높은 보안성을 제공하고, 네트워크 내에서 신뢰할 수 없는 노드가 있더라도 신뢰할 수 있는 결과를 얻을 수 있음. 단점: PoW나 PoS에 비해 복잡하며, 네트워크가 커질수록 속도가 느려질 수 있음. 실용 비잔틴 장애 허용 (Practical Byzantine Fault Tolerance, PBFT): 사용 예시: Hyperledger Fabric 특징: 네트워크 내에서 과반수 이상의 노드가 동일한 상태에 도달해야 합의가 이루어짐. QBFT (Quorum-based Byzantine Fault Tolerance) 설명: QBFT는 비잔틴 장애 허용(Byzantine Fault Tolerance, BFT) 계열의 합의 알고리즘 중 하나로, 네트워크 내의 노드들이 합의에 도달하기 위해 과반수 이상의 노드의 승인을 요구하는 방식입니다. 비잔틴 장애를 허용하면서도 네트워크의 안전성과 효율성을 유지하려는 목적에서 개발되었습니다. PBFT(Practical Byzantine Fault Tolerance) 알고리즘에서 발전된 형태입니다. 예시: Hyperledger Besu에서 사용되며, 주로 기업용 블록체인에 적합한 알고리즘으로 알려져 있습니다. 장점: 네트워크 내 악의적인 노드가 있더라도, 과반수의 신뢰할 수 있는 노드가 있으면 안전하게 합의에 도달할 수 있습니다. 또한, PoW처럼 에너지 소비가 크지 않으며, 빠른 트랜잭션 처리가 가능합니다. 단점: 네트워크 규모가 커질수록 합의에 필요한 통신 비용이 증가하여 성능이 저하될 수 있습니다. 노드 수가 많아질수록 네트워크의 처리 속도가 느려질 수 있습니다. QBFT는 비잔틴 장애 허용을 기반으로 하면서도 성능과 확장성을 유지하려는 알고리즘으로, 주로 엔터프라이즈 블록체인 환경에서 사용됩니다.\n혼합 합의 알고리즘 (Hybrid Consensus): 사용 예시: Decred 특징: 두 가지 이상의 합의 알고리즘을 결합하여 안정성과 효율성을 극대화. Raft 알고리즘 설명: Raft는 분산 시스템에서 여러 노드가 일관된 상태를 유지할 수 있도록 리더 기반 구조로 동작하는 합의 알고리즘입니다. 리더가 클라이언트 요청을 처리하고, 그 로그를 팔로워 노드에 복제하여 일관성을 유지합니다. 리더가 장애가 발생하면 새로운 리더가 투표를 통해 선출됩니다. 예시: Etcd, Consul. 장점: 구조가 간단하고 이해하기 쉬워 구현이 용이하며, 리더 선출과 로그 복제가 빠르고 안정적입니다. 단점: 리더에 의존적인 구조이기 때문에 리더가 자주 변경되면 성능이 저하될 수 있고, 리더 장애 시 복구 시간이 필요합니다. Tendermint: 사용 예시: Cosmos 특징: BFT 기반으로 빠르고 안정적으로 합의를 달성하는 알고리즘. PoS와 결합하여 사용. 기타 합의 알고리즘 Federated Byzantine Agreement (FBA): 리플, 스텔라에서 사용. Leased Proof of Stake (LPoS): 웨이브(Waves)에서 사용. Proof of Burn (PoB): 특정 양의 암호화폐를 소각하여 블록 생성 권한을 얻는 방식. ","permalink":"https://findmytrueself.github.io/ko/blockchain/%ED%95%A9%EC%9D%98-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","tags":["Blockchain"],"title":"합의 알고리즘"},{"categories":null,"content":"이더리움이란? 블록체인 기반 플랫폼: 스마트 계약과 탈중앙화 애플리케이션(dApps) 실행하는데 사용 된다.\n암호화폐 거래 이상의 다양한 기능(스마트계약 함수)을 제공한다\n이더리움 네트워크는 수많은 노드로 구성되어 있으며, 각 노드는 이더리움 블록체인을 유지하고 검증하는 역할을 한다.\n이더리움 가상 머신 (EVM, Ethereum Virtual Machine)\n이더리움 네트워크 내에서 스마트 계약을 실행하는 가상화된 컴퓨팅 환경\n스마트 계약과 탈중앙화 애플리케이션의 핵심요소\n가상화된 컴퓨터로, 이더리움 네트워크에서 분산적으로 실행\n스마트 계약은 Solidity 언어로, 바이트코드로 컴파일되어, EVM에서 이 바이트코드를 읽어 실행한다.\nERC\n이더리움 블록체인에서 스마트 계약 표준을 제안하고 정의하는 프로세스이다.\nERC-20: 설명: 가장 널리 사용되는 토큰 표준으로, 이더리움 블록체인에서 **대체 가능한 토큰(fungible token)**을 생성하는 표준입니다. ERC-20 토큰은 동일한 값과 속성을 가지며, 모든 단위가 동등하게 취급됩니다. 사용 예시: 대부분의 ICO(Initial Coin Offering)에서 사용된 토큰, 다양한 프로젝트의 유틸리티 토큰 등. 기능: transfer, approve, transferFrom 등의 기본적인 토큰 전송 및 승인 기능을 정의. ERC-721: 설명: 대체 불가능한 토큰(NFT, Non-Fungible Token) 표준으로, 각 토큰이 고유한 속성을 가지며, 다른 토큰과 동등하게 교환되지 않습니다. 사용 예시: 디지털 자산(예: CryptoKitties), 예술품, 게임 아이템 등의 소유권을 나타내는 토큰. 기능: ownerOf, transferFrom 등을 통해 특정 토큰의 소유권을 추적하고 전송. ERC-1155: 설명: 다중 토큰 표준으로, 하나의 계약에서 대체 가능한 토큰과 대체 불가능한 토큰을 동시에 관리할 수 있습니다. 사용 예시: 게임에서 다양한 유형의 아이템(일반 아이템과 고유 아이템)을 관리할 때 유용. 기능: safeTransferFrom, balanceOf 등을 사용해 여러 유형의 토큰을 효율적으로 전송 및 관리. ERC-777: 설명: ERC-20의 개선된 토큰 표준으로, 더 유연한 전송 메커니즘과 보안 기능을 제공합니다. 특히, 토큰 전송 시 사용자 정의된 후크(hook) 기능을 사용할 수 있습니다. 사용 예시: ERC-20의 한계를 극복하고 더 복잡한 스마트 계약 시스템에서 사용. ERC-1400: 설명: 보안 토큰을 위한 표준으로, 법적 요구사항을 충족시키기 위해 토큰 소유권을 더욱 엄격하게 관리하는 기능을 제공합니다. 사용 예시: 증권형 토큰(보안 토큰), 규제 요건이 중요한 금융 자산. ","permalink":"https://findmytrueself.github.io/ko/blockchain/ethereum/","tags":["Blockchain","Ethereum"],"title":"Ethereum"},{"categories":null,"content":"클로저는 자바스크립트에서 기본이 되는 아주 중요한 개념이다.\n기술 면접에서 1순위로 자주 물어보는 개념이기 때문에, 나도 기술 면접을 준비하며 외웠던 기억이 난다.\n하지만, 실무에서 클로저가 어떻게 쓰이는지 잘 이해하지 못했고, 이를 실제로 어떻게 응용해야 할지 고민하던 시기가 있었다. 이번에 클로저 개념을 더 심도 있게 공부해보려 한다.\n문제\ncustomHook에 함수를 파라미터로 넘겨줄 때, useCustom 컴포넌트가 언마운트되는 상황에서 해당 함수가 실행될 때, 함수 내부의 state 값이 어떻게 출력되는지 살펴보자.\nimport useCustom from \u0026#39;./hooks/useCustom\u0026#39; import { useState } from \u0026#39;react\u0026#39; export default function Home() { const [state, setState] = useState(0) useCustom(() =\u0026gt; console.log(\u0026#39;inner func state:\u0026#39;, state)) return ( \u0026lt;div className=\u0026#34;grid grid-rows-[20px_1fr_20px] items-center justify-items-center min-h-screen p-8 pb-20 gap-16 sm:p-20 font-[family-name:var(--font-geist-sans)]\u0026#34;\u0026gt; \u0026lt;div\u0026gt;{state}\u0026lt;/div\u0026gt; \u0026lt;button onClick={() =\u0026gt; setState(state + 1)}\u0026gt;+\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ) } import React, { useEffect } from \u0026#39;react\u0026#39; const useCustom = (func: Function, state: any) =\u0026gt; { console.log(\u0026#39;params state:\u0026#39;, state) useEffect(() =\u0026gt; { return () =\u0026gt; func() }, []) return \u0026lt;div\u0026gt;useCustom\u0026lt;/div\u0026gt; } export default useCustom 코드 설명\n초기 렌더링 시 state는 0으로 설정된다. useCustom 훅 내부의 console.log에 출력되는 state 값은 초기 값인 0이다. 이때 useCustom에서 넘겨준 func 함수도 클로저로 인해 state가 0인 상태를 기억하게 된다. 이후 useCustom 컴포넌트가 언마운트될 때 해당 함수가 실행되지만, 그때의 state는 0으로 남아 있다. 의존성 배열이 빈 배열이기 때문에 useEffect는 한 번만 실행되며, state가 바뀌더라도 재실행되지 않는다. 만약 최신 state 값을 사용하고 싶다면, useEffect의 의존성 배열에 state를 추가해 주어야 한다. 그렇지 않으면 클로저로 인해 이전 상태를 참조하게 된다. ","permalink":"https://findmytrueself.github.io/ko/frontend/%EB%A6%AC%EC%95%A1%ED%8A%B8%EC%97%90%EC%84%9C%EC%9D%98-%ED%81%B4%EB%A1%9C%EC%A0%80/","tags":["Javascript","React"],"title":"리액트에서의 클로저"},{"categories":null,"content":"나는 현 회사에서 3년차 프론트 개발자이다.\n나름 회사에서 중요한 많은 일을 했다고 생각했는데, 또 막상 뭘했냐고 했을 때 자신있게 답하기가 민망하다.\n또, 최근 업데이트 된 챗지피티 4o를 쓰면서, 점점 의지하고 있는게 느껴졌다.\n모든 일엔 100%는 없다 라고 항상 생각하는데, 엔진이 업그레이드 되면 될 수록 정답에 가까운 답을 찾아준다.\n유료버전을 사용 하기 전에는 바보같은 대답만 하던 챗지피티를 무시했었는데, 지금은 정말 다르다.\n사실상 항상 구글링을 통해 해결했던 그 방식과 사실 같나? 모르겠다. 구글링을 통한 답 찾기는 괜찮고, 챗지피티는 안된다? 그것도 이상하다.\n어쨌든, 나는 그 사이에서 앞으로 어떤 커리어를 가져가야하나 고민이 많다.\n취업문은 점점 좁아지고, 뜻대로 이직도 잘 안돼서 몸소 느끼고있는 바이다.\n계속 도전해야 하는 것 같다. 공부도 계속 해야하고, 내일은 오늘보다 낫게끔 마음을 먹고 살아가려고한다.\n","permalink":"https://findmytrueself.github.io/ko/diary/%EB%AF%B8%EB%9E%98%EC%97%90-%EB%8C%80%ED%95%9C-%EA%B3%A0%EB%AF%BC/","tags":null,"title":"미래에 대한 고민"},{"categories":null,"content":"Set의 사용\n일반 배열을 사용한 방식의 차이는 중복된 요소를 어떻게 처리하는가이다.\nlet setArr = new Set([\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;d\u0026#39;,\u0026#39;a\u0026#39;]) console.log(setArr) // 출력: Set(4) { \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39; } Set은 중복을 허용하지 않는 데이터 구조이다. 즉, Set에 같은 값을 여러 번 추가하려고 해도, 중복된 값은 하나만 유지된다. Set을 배열로 변환하려면 Array.from()을 사용 할 수 있다. let report = [\u0026#34;muzi frodo\u0026#34;, \u0026#34;apeach frodo\u0026#34;, \u0026#34;frodo neo\u0026#34;, \u0026#34;muzi neo\u0026#34;, \u0026#34;muzi frodo\u0026#34;]; let uniqueReports = new Set(report); console.log(uniqueReports); // 출력: Set(4) { \u0026#39;muzi frodo\u0026#39;, \u0026#39;apeach frodo\u0026#39;, \u0026#39;frodo neo\u0026#39;, \u0026#39;muzi neo\u0026#39; } Set의 특징\n중복을 자동으로 제거 순서가 중요한 상황이 아니라면, 중복 요소를 제거 할 때 유용하다. ","permalink":"https://findmytrueself.github.io/ko/algorithm/set/","tags":["Algorithm","Javascript"],"title":"Set을 사용하는 배열"},{"categories":null,"content":"ADHD는 요즘 많이 어디선가 들리는 단어다.\n주의력 결핍 과다행동 장애\n주의력이 떨어지므로 산만하고, 충동적이다.\n정신질환이 아니라, 발달장애라고 한다.\n어린시절의 나\n내 정말 어릴적을 지금 돌이켜보면, 책을 한번 읽으면 10권 20권도 앉은자리에서 읽었다. 엄마는 천재를 낳았다며, 내심 기대를 했었나보다.\n초등학교에 들어오고 나서부터는 책을 아예 안읽었다. 그 시간에 게임만 했다.\n내가 ADHD인지는 아직도 모르겠지만, 내가 좋아하는 영역이 아니면, 지금도 앉아서 책읽기가 어렵다.\n초등학교 생기부를 볼 수 있었는데, 초1,초2때 산만하다고 써있었다. 선생이 나를 싫어해서 그런말을 적었다고 생각했다.\nADHD 특징이 시간관념이 없다라는 것이다.\n지금도 그렇고, 지각을 자주했다. 고등학교 때는 지각 하면 맞았는데, 나만 3연속 지각을 해서, 첫날 10대, 둘째날 20대, 셋째날 30대를 맞았던 경험이 있다.\n30대씩 피멍들어가며 맞아가면서 지각하고 싶어서 했겠는가.. 옛날일이니깐.. 지금은 웃으면서 얘기하고 싶다.\n평소보다 30분 더 일찍 나가면 되는건데, 나는 항상 그게 안된다.\n빨리 나가려는 마음이 일단 안생기고, 억지로 시간 맞춰 겨우겨우 나가면, 뭔가 빠뜨린게 있는가 확인하고, 차를 놓치고, 마음은 누구보다 바쁜데 결과적으로 항상 늦다.\n그러고보니, 중학교 때는 걸어서 3분 거리 임에도 불구하고 지각을 자주 했었다. 좀 덜하긴 했으나, 거리는 의미가 없는 것 같다.\n요즘의 나\n항상 일찍 일어나야한다는 압박감에 살고 있고, 출근시간을 맞춰야 한다는 압박에 살고 있다.\n나는 이 회사가 좋았던게, 출퇴근시간이 자율이라 언제든 업무에만 집중 하면 된다는 생각에 편하게 다녔다.\n하지만, 점점 그런 분위기와 멀어지는 것 같아서, 심적으로 힘들다. 회사를 옮기고 싶다.\n내가 이상적으로 생각하는 회사는 알아서 자기 할 일 잘하는 그런 분위기 인데, 점점 그런 이상적인 모습과는 거리가 멀어지고 있는 것 같다.\n신경정신과 방문\n우울증이 심해져서, 최근 불면이 심하다. 최근 신경정신과에 난생 처음 방문하게 되었다.\n계기는 이틀밤을 거의 한두시간만 잤음에도 불구하고, 여전히 잠이 안와서였다.\n말을 잘 들어주시고, 누군가에게 나의 불편함을 속 시원히 털어놓고 나니 한결 기분이 좋아졌다.\n의사선생님께서 ADHD인 것 같다고, ADHD 검사를 다음 기회에 해보자고 하셨다.\n약들은 효과가 좋았다. 잠이 잘 왔다. 그 약을 먹고는 8시간씩 정말 깊게 잘 수 있었다. 약기운이 다음날까지 있는지 낮에도 몽롱한 기분이 있다.\n그러고보니, 화도 많이 줄어든 것 같다.\n좀 걱정 되는 건, 밤에 정신이 멀뚱멀뚱하면 계속 그 약(자낙스)을 찾는 것 같아, 적당히 스스로 조절해야겠다.\n","permalink":"https://findmytrueself.github.io/ko/diary/adhd/","tags":null,"title":"나는 ADHD 일까?"},{"categories":null,"content":"인생에 있어서 가장 큰 시련이왔다.\n올해 초 투자로 많은 돈을 벌었고 지나친 자신감이 생겼다.\n큰 베팅을 계속해서 하게 되었고, 결국 큰 손실을 봤다.\n정신이 무너지는걸 날마다 느끼는 순간이었다.\n일은 손에 전혀 잡히질 않았고, 한동안 공황장애 증세가 있었다.\n때마침 급하게 끝내야 할 하나의 프로젝트가 생겨서, 한달 간은 해당 업무에 집중하며 밤낮 가리지 않고 시간을 보냈다.\n딴생각 안났기 때문에 끝날때 까지 정신을 버틸 수 있었다.\n프로젝트가 끝나고, 다시 번아웃이 왔다.\n회사에서 멍때리는게 일과였다.\n유튜브에서 정신병에 대해 시청을 하며 공부를 많이 하게 되었다.\n나르시시스트라는 개념에 대해 알게 되었고, 주변에 상당히 많이 있었고, 알게모르게 나는 고갈되고 있었다.\n우울증이 심해졌다. 언제 활짝 웃었는지 기억이 나질 않는다.\n아직 나를 놓치 않았기 때문에 다시 일어서보려고 노력 한다.\n이 블로그도 그 발판이 되었으면 한다. 집도 치우고, 운동도 다시 시작하고.. 공부도 더 해야한다.\n최근 이직 면접을 보고, 간단한 질문에 대해 대답을 못하는 자신이 한심했다.\n마음이 너무 급하다. 천천히 꾸준히 하는게 중요하다. 게임도 이제 재미가 없다. 더이상 올라갈 실력이 안되는 것 같다.\n앞으로 그 시간을 나를 수양하는데 써야겠다.\n","permalink":"https://findmytrueself.github.io/ko/diary/2024/","tags":null,"title":"2024 시련"},{"categories":null,"content":"순열은 고등학교 수학 때 배우는 개념이다.\n그때는 무작정 공식만 외웠기 때문에, 순열이 무엇인지, 언제 쓰이는지 몰랐다.(어릴때 공부를 잘못했던 이유인듯 \u0026hellip;)\n순열이란?\n순열(Permutation)은 집합에 속한 모든 원소의 순서를 고려하여 배열하는 것을 의미합니다.\n즉, 주어진 n개의 원소를 모두 사용하여 만들 수 있는 가능한 모든 순서의 조합을 말합니다.\n순열의 특징\n순열은 순서가 중요합니다. 즉, {1, 2, 3}과 {3, 2, 1}은 서로 다른 순열로 취급됩니다. n개의 원소로 만들 수 있는 순열의 개수는 n! (n 팩토리얼)로 계산됩니다. 예를 들어, 3개의 원소가 있을 때 순열의 개수는 3! = 3 × 2 × 1 = 6개입니다. 순열의 활용\n모든 가능한 순서를 고려해야 할 때 (예: 일정을 짜는 문제) 경우의 수를 모두 나열하여 최적의 선택을 해야 할 때 (예: 최단 경로 찾기) JS 함수\nfunction getPermutations(arr) { let results = [] function permute(current, remaining) { if (remaining.length === 0) { results.push(current) } for (let i = 0; i \u0026lt; remaining.length; i++) { let next = current.concat(remaining[i]) let newRemaining = remaining.slice(0, i).concat(remaining.slice(i + 1)) permute(next, newRemaining) } } permute([], arr) return results } const array = [1, 2, 3] const permutations = getPermutations(array) console.log(permutations) /** [ [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1] ] */ ","permalink":"https://findmytrueself.github.io/ko/algorithm/permutation/","tags":["Algorithm","Javascript"],"title":"순열(Permutation)"},{"categories":null,"content":"Array.at(idx)은 es2022부터 등장한 메소드이다.\n기존 방식의 Array[idx]과 어떤 차이가 있는지 알아보자.\n차이\n가장 극명한 차이는 음수 인덱스 지원에 있다.\nconst arr = [10, 20, 30] console.log(arr[-1]) // undefined const arr = [10, 20, 30] console.log(arr.at(-1)) // 30 ","permalink":"https://findmytrueself.github.io/ko/algorithm/arrayat/","tags":["Algorithm","Javascript"],"title":"Array.at과 Array[idx]의 차이"},{"categories":null,"content":"코딩테스트 중에 숫자 N이 주어졌을 때 N개의 배열을 만들어서 forEach를 하고 싶었다.\n그냥 for문이나 while문으로 하면 되겠지만, 배열의 메소드가 익숙해버려서, 해당 방법을 찾기 시작했다.\n1중배열 (n개의 배열)\nfor function createArray(n) { const result = [] for (let i = 1; i \u0026lt;= n; i++) { result.push(i) } return result } while function createArray(n) { const result = [] let i = 1 while (i \u0026lt;= n) { result.push(i) i++ } return result } Array.from //* Recommend const array = Array.from({ length: n }, (_, i) =\u0026gt; i + 1) Array.map const array = Array(n) .fill() .map((_, i) =\u0026gt; i + 1) 2중배열로 만들기, ex)[[1], [1,2], [1,2,3], [1,2,3,4], [1,2,3,4,5]]\nfor function createArrays(n) { const result = [] for (let i = 1; i \u0026lt;= n; i++) { const arr = [] for (let j = 1; j \u0026lt;= i; j++) { arr.push(j) } result.push(arr) } return result } while function createArrays(n) { const result = [] let i = 1 while (i \u0026lt;= n) { const arr = [] let j = 1 while (j \u0026lt;= i) { arr.push(j) j++ } result.push(arr) i++ } return result } Array.from //* Recommend function createArrays(n) { return Array.from({ length: n }, (_, i) =\u0026gt; Array.from({ length: i + 1 }, (_, j) =\u0026gt; j + 1) ) } Array.map function createArrays(n) { return Array(n) .fill() .map((_, i) =\u0026gt; Array(i + 1) .fill() .map((_, j) =\u0026gt; j + 1) ) } n x n 2차원 배열 만들기\nArray.from({ length: n }, () =\u0026gt; Array(n).fill(0)) ","permalink":"https://findmytrueself.github.io/ko/algorithm/makearraywithnumber/","tags":["Algorithm","Javascript"],"title":"N개의 숫자의 배열 만들기"},{"categories":null,"content":"해당 궁금증을 해소 하기 전 배경에는, useEffect dependency 배열에 함수가 들어가는 상황에 대해서 공부하고 있던 시점이다.\n보통 커스텀 훅을 만들 때에는 해당 훅 컴포넌트의 props에 상태 값을 받아오고, 그 상태 값을 useEffect 내부 dependency배열에 넣어 동작을 처리 한다.\n그렇다면 함수를 props로 받아올 땐 어떤가? 고민해보았다.\n함수가 의존성 배열에 들어가는 이유\n리액트 컴포넌트가 렌더링될 때마다 함수는 다시 생성된다.\n자바스크립트에서는 함수가 일급 객체이므로, 동일한 이름의 함수라도 매 렌더링 시 새롭게 생성된 함수는 이전 함수와 다르게 취급된다.\n따라서, 의존성 배열에 함수가 포함되면 그 함수가 매 렌더링마다 재생성될 때마다 useEffect가 다시 실행된다.\nuseCallback을 사용 할 때 예제\nimport React, { useState, useEffect, useCallback } from \u0026#39;react\u0026#39; function SearchComponent() { const [searchQuery, setSearchQuery] = useState(\u0026#39;\u0026#39;) const [results, setResults] = useState([]) const fetchData = useCallback(() =\u0026gt; { fetch(`https://api.example.com/search?q=${searchQuery}`) .then((response) =\u0026gt; response.json()) .then((data) =\u0026gt; setResults(data.results)) .catch((error) =\u0026gt; console.error(\u0026#39;Error fetching data:\u0026#39;, error)) }, [searchQuery]) // fetchData 함수는 searchQuery에 의존합니다. useEffect(() =\u0026gt; { fetchData() }, [fetchData]) // fetchData 함수가 의존성 배열에 포함됩니다. return ( \u0026lt;div\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; value={searchQuery} onChange={(e) =\u0026gt; setSearchQuery(e.target.value)} /\u0026gt; \u0026lt;ul\u0026gt; {results.map((result, index) =\u0026gt; ( \u0026lt;li key={index}\u0026gt;{result.name}\u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ) } export default SearchComponent useCallback을 사용하지 않을 때 예제\nimport React, { useState, useEffect } from \u0026#39;react\u0026#39; function SearchComponent() { const [searchQuery, setSearchQuery] = useState(\u0026#39;\u0026#39;) const [results, setResults] = useState([]) useEffect(() =\u0026gt; { const fetchData = () =\u0026gt; { fetch(`https://api.example.com/search?q=${searchQuery}`) .then((response) =\u0026gt; response.json()) .then((data) =\u0026gt; setResults(data.results)) .catch((error) =\u0026gt; console.error(\u0026#39;Error fetching data:\u0026#39;, error)) } fetchData() }, [searchQuery]) // searchQuery가 변경될 때마다 useEffect가 실행됩니다. return ( \u0026lt;div\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; value={searchQuery} onChange={(e) =\u0026gt; setSearchQuery(e.target.value)} /\u0026gt; \u0026lt;ul\u0026gt; {results.map((result, index) =\u0026gt; ( \u0026lt;li key={index}\u0026gt;{result.name}\u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ) } export default SearchComponent 차이점\n함수 생성 및 메모리 사용 useEffect 내부에서 함수를 직접 정의할 경우, 이 함수는 searchQuery가 변경될 때마다 useEffect와 함께 새로 정의됩니다. 매번 함수가 새로 생성되기 때문에 메모리 사용이 늘어날 수 있고, 함수의 정의 자체가 매번 새로 생성되는 것은 불필요한 연산을 초래할 수 있습니다. 이 차이는 성능에 민감한 애플리케이션에서 영향을 미칠 수 있으며, 특히 자주 렌더링되는 컴포넌트에서는 부정적인 영향을 줄 수 있습니다. 의존성 관리 useCallback을 사용하여 함수를 감싸지 않은 경우, 의존성 배열에서 함수 자체가 의존성으로 추가되지 않습니다. useEffect는 오직 searchQuery가 변경될 때만 실행됩니다. 이 경우 searchQuery가 변경될 때마다 fetchData 함수가 새로 정의되지만, 이로 인해 의존성 관리가 복잡해지지 않으며, 단순히 매번 함수가 새로 정의되는 방식으로 동작하게 됩니다. 불필요한 리렌더링 방지 useCallback을 사용하여 함수를 정의할 때, 이 함수는 의존성 배열에 있는 값이 변경될 때만 새로 생성됩니다. 이는 컴포넌트가 불필요하게 리렌더링되는 것을 방지합니다. useCallback을 사용하지 않으면 fetchData 함수가 매번 새로 생성되고, 이로 인해 만약 다른 의존성을 관리하는 부분이 있다면, 의도치 않게 불필요한 리렌더링이 발생할 수 있습니다. useCallback을 쓰는 상황\n복잡한 컴포넌트 상태 관리가 많을 때: 여러 개의 상태를 관리하고, 각 상태가 서로 복잡하게 상호작용할 때 컴포넌트가 복잡해집니다. 예를 들어, 폼(form)과 같은 컴포넌트에서 많은 입력 필드의 상태를 관리하거나, 다양한 이벤트에 따라 UI가 동적으로 변하는 경우가 있습니다. 자식 컴포넌트가 많을 때: 컴포넌트가 여러 자식 컴포넌트를 렌더링하고 이들 간에 많은 데이터를 주고받을 때 복잡성이 증가합니다. 특히 자식 컴포넌트들이 각각 독립적인 상태를 관리하거나, 부모 컴포넌트의 상태를 공유해야 하는 경우입니다. 조건부 렌더링이 많을 때: 컴포넌트가 다양한 조건에 따라 서로 다른 UI를 렌더링해야 하는 경우, 여러 가지 조건문(if, switch, 삼항 연산자 등)이 사용되면서 코드가 복잡해질 수 있습니다. 성능이 민감한 경우 자주 렌더링되는 컴포넌트: 화면에 자주 렌더링되거나, 사용자가 인터랙션할 때마다 빠르게 반응해야 하는 컴포넌트입니다. 예를 들어, 실시간으로 업데이트되는 대시보드, 채팅 애플리케이션, 애니메이션 효과가 많은 UI 등이 여기에 해당합니다. 대량의 데이터를 처리할 때: 컴포넌트가 한 번에 많은 데이터를 처리하거나 렌더링해야 하는 경우입니다. 예를 들어, 테이블에 수천 개의 행을 렌더링해야 하는 경우나, 복잡한 그래프를 그려야 하는 상황이 이에 해당합니다. 최적화가 필요한 경우: 특정 작업이 자주 발생하면서 성능에 부정적인 영향을 미치는 경우 최적화가 필요합니다. 예를 들어, 불필요한 리렌더링을 줄이기 위해 React.memo, useCallback, useMemo와 같은 리액트의 최적화 훅을 사용해야 할 때가 있습니다. 이러한 상황에서는 컴포넌트가 효율적으로 동작하지 않으면 사용자 경험이 저하될 수 있으므로, 코드의 최적화나 리액트의 성능 관련 기능들을 활용하는 것이 중요합니다.\n결론\nuseCallback을 사용하지 않는 경우: useEffect 내부에서 직접 함수를 정의하고 실행하면, 해당 함수는 의존성 배열에 포함된 값이 변경될 때마다 새로 생성되며 메모리와 성능에 영향을 미칠 수 있습니다. 하지만 간단한 상황에서는 별다른 문제가 없을 수 있습니다. useCallback을 사용하는 경우: 함수가 불필요하게 재생성되는 것을 방지하여 성능 최적화에 기여할 수 있습니다. 특히, 함수가 자주 재생성되는 경우 이 방법이 더 효율적일 수 있습니다. 따라서, 작은 규모의 컴포넌트에서는 큰 차이가 없을 수 있지만, 복잡한 컴포넌트나 성능에 민감한 경우라면 useCallback을 사용하여 함수를 메모이제이션(memoization)하는 것이 더 나은 선택이 될 수 있습니다.\n","permalink":"https://findmytrueself.github.io/ko/frontend/usecallback/","tags":["Javascript","React"],"title":"useCallback"},{"categories":null,"content":"flex-basis\nwidth 랑 비슷한 개념\n최초의 박스의 크기를 지정 할 수 있다.\nflex-grow\n전체 박스의 크기에서 빈 부분을 값을 1을 주면 채울 수 있다. 기본값 0\nflex-shrink\n동적으로 해당 박스의 크기를 줄일 수 있다. 기본값 1\nflex-wrap\n박스의 화면을 초과 하면 밑으로 내릴 수 있다.\n","permalink":"https://findmytrueself.github.io/ko/frontend/flexbox/","tags":["CSS"],"title":"FlexBox"},{"categories":null,"content":"9월, 개발 세팅 및 코드 분석\n22년 9월, 기존 크롬에 배포 된 블록체인 지갑을 리뉴얼 하는 작업을 맡게 되었다.\n최초 이 일을 맡게 되었을 당시에 정말 막막했었다. Vue2로 개발되어있던 기존 프로젝트를 수정해야 했었고, 크롬은 Manifest라는 정책을 따르기 때문에 관련해서 또 공부를 했어야 했다.\nManifest v3 이슈가 처음부터 있었고, 리액트로 개발을 주로 하였어서 처음부터 다시 짜는게 어떨까 생각하고, 시도를 해봤지만, 처음 구조부터 다시 짤 자신이 없었다.\nSPA 구조를 알았기 때문에, Vue2 문법과 구조를 쉽게 파악 할 수 있었지만, 크롬 개발은 기존 웹개발과 또 다른 영역 같았다.\n기존 개발 된 기능을 다시 개발 하기에는 인력도 시간도 능력도 부족했다. 울며 겨자먹기로 기존 코드를 리팩터링 했었던 것 같다.\n10월~11월, 디자인 수정 및 데이터 구조 변경\n기존 버전의 단순한 디자인에서 좀더 화려한 디자인으로 수정이 되었고, Flow도 많이 바뀌었다.\n많은 기능들은 기존 코드를 재사용 또는 약간의 수정을 거쳤다.\n프론트엔드 영역에서는 DB라는게 없기 때문에, 브라우저의 스토리지를 사용하여 데이터를 저장하고, 필요할때 꺼내 쓴다.\nScan에 저장 되어 있는 데이터를 가져와서 유저에게 보여주는 방식으로 리팩터링 하였고, 유저에게 필요한 데이터들은 스토리지에 저장하여 꺼내썼다.\nView단에 보여지는 모든 상태는 vuex store에서 상태관리를 한다.\n비동기 통신 작업을 위해 action dispatch, mutations commit 메소드로 상태관리.\ngetter와 computed를 사용하여 상태를 감지한다.\n12월~1월, Manifest 이슈 발생 및 원인 발견\n보안상 구글 크롬 Manifest v3으로 2023년에 무조건 업그레이드를 해야한다고 이미 얘기가 나와있었다.\n해당 이슈에 대해서 인지를 하고 있음에도 불구하고, 개발을 하게되었는데.. 알고보니 생각보다 더큰 문제였다.\n기존에 사용되는 background 로직이 완전 다 바뀌어야 하는 심각한 상황이 발생해버렸다.\n먼저, manifest 버전업이 힘들었던 원인은 참조하고 있던 블록체인 SDK에서 생긴 원인이었다. SDK에서 알 수 없는 에러를 내서 background 스크립트를 읽어 올 수 없었다.\n원개발자인 외국인 개발자에게 협조를 요청했고, SDK 수정 이후에 Menifest 버전을 올릴 수 있었다.\n2월, background 로직 수정\nmanifest 버전에 올라 가면서, chrome runtime 객체의 구조가 바뀌었고, background 구동 방식이 기존 html페이지에서 serviceworker.js 로 바뀌었기 때문에 많은게 바뀌어야 하는 상황이 생겼다.\n먼저, background가 항상 떠 있는 방식에서, 현재는 보안 이슈 때문에 295초 마다 background.js가 자동으로 꺼지는 방식으로 되어버렸기 때문에, 계속 살려주는 로직이 필요했다.\n수많은 검색을 한 결과, background를 살릴 수 있는 방법을 찾았고, 적용 했다.\nPersistent Service Worker in Chrome Extension 3월, 크롬 스토어에 배포 준비 및 버그 수정\n제품 디테일에 박차를 가해야한다. 기존 로직에서 중복되는 값들을 모두 제거 하면서, 안정성을 높였다.\nQA 담당분과 함께 테스트하며 수많은 잘잘한 버그들을 수정하면서, 디테일을 높였고, 정식 배포를 앞두고 있다.\n","permalink":"https://findmytrueself.github.io/ko/blockchain/blockchainwalletchromeextension/","tags":["Javascript","Web3","Blockchain"],"title":"블록체인 지갑 Chrome Extension 개발기"},{"categories":null,"content":" 특정한 키를 통해 데이터를 관리하므로, 중복 호출이 될 때, 한번만 호출 하므로 성능에 좋다. ex) custom hook을 통해, fetch문을 만들어, 사용하게 되면, 사용 될 때 마다 호출을 하기 때문에, 같은 데이터라도 불필요한 호출을 하게 된다.\nQuery Keys\nReact Query는 캐싱화된 쿼리들을 쿼리 키로써 관리한다. 복잡한 객체와 복잡하고 많은 문자열들을 배열로 관리하고 있다.\nSerializable하므로, 유니크한 쿼리 데이터로 관리된다.\nuseQuery([\u0026#39;todos\u0026#39;], () =\u0026gt; {...}) useQuery([\u0026#39;todos\u0026#39;, 5, { preview : true }], () =\u0026gt; {...}) useQuery([\u0026#39;todos\u0026#39;, { type: \u0026#39;done\u0026#39;}], () =\u0026gt; {...}) 원하는 요청을 배열로 요청하면, 유니크한 키로써 캐싱화하여 데이터를 관리한다. 활용 예제\nconst Products = () =\u0026gt; { const [checked, setChecked] = useState(false) const { isLoading, error, data: products, } = useQuery([\u0026#39;products\u0026#39;, checked], async () =\u0026gt; { return fetch(`data/${checked ? \u0026#39;sale_\u0026#39; : \u0026#39;\u0026#39;}products.json`).then((res) =\u0026gt; res.json() ) }) } checked 상태가 변화 할 때 fetch요청을 한다. 문제점\n캐싱화되어있다고 생각 하는데 console로 확인해보면, 중복 데이터(이미 렌더링 처리 된 UI나 변화없는 데이터 등등의 상황) 매순간 반복 요청 하는 문제점\nReact Query의 중요한점\nReact Query는 공격적으로 설정되어있지만, 잘 분별 하게도 설정되어있다. 이러한 점은 잘모르는 뉴비들에게 배우기 어렵고 디버깅하기 어렵게 설정되어있다.\nuseQuery, useInfiniteQuery는 기본적으로 stale한 캐시데이터로 간주된다. (stale : 죽은 상태)\nstaleTime이라는 옵션을 전역적으로 설정해주므로써 컨트롤 할 수 있다. staleTime이 설정되어 있는 동안에는 캐싱화된 query 데이터를 refetch하지 않을 것이다. New instances of the query mount The window is refocused The network is reconnected The query is optionally configured with a refetch interval refetch가 내 의도와 상관없이 될 때는, window가 focus가 될 때를 의심해보자\nrefetchOnWindowFocus기능이 기본값으로 켜져있기 때문에 발생한다. dev 환경일 때, devtools를 사용하게 되면, 또한 window를 왔다갔다 하기 때문에, refetch가 계속해서 일어나게 된다. -\u0026gt; refetchOnMount,refetchOnWindowFocus, refetchOnReconnect,refetchInterval 설정을 바꾸자\nuseQuery, useInfiniteQuery를 더이상 사용하지 않으면, inactive상태가 된다. 이 상태가 5분간 지속되면 자동적으로 garbage collect가 된다. -\u0026gt; cacheTime의 설정을 바꾸자. 1000 * 60 * 5 이상의 값(5분이상)을 준다.\nQuery가 실패할 때, 3번 재반복 실행을 한다. 3번 반복(기본값 : 3)할 때, 간격이 점점 길어짐. -\u0026gt; retry, retryDelay로 설정한다.\nstale 상태에 따른 데이터 통신 순서\n업데이트 하기\n업데이트 되면 기존 쿼리는 invalidate 시켜주면 다시 저절로 fetch를 하게 된다.\nconst client = useQueryClient() \u0026lt;button onClick={()=\u0026gt;client.invalidateQueries([\u0026#39;products\u0026#39;, false])}\u0026gt;정보 업데이트 하기!\u0026lt;/button\u0026gt; Redux -\u0026gt; React-Query 전환\nLink : [Redux -\u0026gt; React-Query 전환][https://youtu.be/hcvcb36wzzk]\n","permalink":"https://findmytrueself.github.io/ko/frontend/reactquery/","tags":["Javascript","React"],"title":"React Query 정리"},{"categories":null,"content":"그동안 리액트를 사용해 오면서, 기본 hooks를 이용하여 대부분의 로직을 수행했다. 하지만 반복되는 코드에 대해 항상 어떻게 하면 재사용성을 늘릴 수 있을까 고민 했었다.\n커스텀 훅을 잘 사용하면 더 높은 레벨의 프론트엔드 개발자가 될 것 같았다.\n커스텀 훅의 가장 중요한 원칙은 \u0026lsquo;값의 재사용이 아닌 로직의 재사용\u0026rsquo; 이다.\n훅 내부에 상태 변화에 대한 값만 매개변수로 지정해주어, Side effect에 따른 로직을 정해준다.\nimport { useState } from \u0026#39;react\u0026#39; function App() { const [inputValue, setInputValue] = useState(\u0026#39;\u0026#39;) const handleChange = (e) =\u0026gt; { setInputValue(e.target.value) } const handleSubmit = () =\u0026gt; { setInputValue(\u0026#39;\u0026#39;) } return ( \u0026lt;div\u0026gt; \u0026lt;input value={inputValue} onChange={handleChange} /\u0026gt; \u0026lt;button onClick={handleSubmit}\u0026gt;확인\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ) } 위의 코드를 custom hook으로 만들어보자.\nimport { useState } from \u0026#39;react\u0026#39; export function useInput(initialValue, submitAction) { const [inputValue, setInputValue] = useState(initialValue) const handleChange = (e) =\u0026gt; { setInputValue(e.target.value) } const handleSubmit = () =\u0026gt; { setInputValue(\u0026#39;\u0026#39;) submitAction(inputValue) } return [inputValue, handleChange, handleSubmit] } import { useInput } from \u0026#39;hooks/useInput\u0026#39; function displayMessage(message) { alert(message) } function App() { const [inputValue, handleChange, handleSubmit] = useInput( \u0026#39;Hello\u0026#39;, displayMessage ) return ( \u0026lt;div\u0026gt; \u0026lt;input value={inputValue} onChange={handleChange} /\u0026gt; \u0026lt;button onClick={handleSubmit}\u0026gt;확인\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ) } import { useState, useEffect } from \u0026#39;react\u0026#39; const baseUrl = \u0026#39;https://jsonplaceholder.typicode.com\u0026#39; function App() { const [data, setData] = useState(null) const fetchUrl = (type) =\u0026gt; { fetch(baseUrl + \u0026#39;/\u0026#39; + type) .json() .then((res) =\u0026gt; { setData(res) }) } useEffect(() =\u0026gt; { fetchUrl(\u0026#39;users\u0026#39;) }, []) return ( \u0026lt;div\u0026gt; \u0026lt;button onClick={() =\u0026gt; fetchUrl(\u0026#39;users\u0026#39;)}\u0026gt;Users\u0026lt;/button\u0026gt; \u0026lt;button onClick={() =\u0026gt; fetchUrl(\u0026#39;posts\u0026#39;)}\u0026gt;Posts\u0026lt;/button\u0026gt; \u0026lt;button onClick={() =\u0026gt; fetchUrl(\u0026#39;todos\u0026#39;)}\u0026gt;Todos\u0026lt;/button\u0026gt; \u0026lt;pre\u0026gt;{JSON.stringify(data, null, 2)}\u0026lt;/pre\u0026gt; \u0026lt;/div\u0026gt; ) } 위의 코드를 custom hook을 이용한 로직으로 바꿔보자.\nimport { useEffect, useState } from \u0026#39;react\u0026#39; export function useFetch(baseUrl, initialType) { const [data, setData] = useState(null) const fetchUrl = (type) =\u0026gt; { fetch(baseUrl + \u0026#39;/\u0026#39; + type) .json() .then((res) =\u0026gt; { setData(res) }) } useEffect(() =\u0026gt; { fetchUrl(initialType) }, []) return { data, fetchUrl, } } import { useFetch } from \u0026#39;hooks/useFetch\u0026#39; const baseUrl = \u0026#39;https://jsonplaceholder.typicode.com\u0026#39; function App() { const { data, fetchUrl } = useFetch(baseUrl, \u0026#39;users\u0026#39;) return ( \u0026lt;div\u0026gt; \u0026lt;button onClick={() =\u0026gt; fetchUrl(\u0026#39;users\u0026#39;)}\u0026gt;Users\u0026lt;/button\u0026gt; \u0026lt;button onClick={() =\u0026gt; fetchUrl(\u0026#39;posts\u0026#39;)}\u0026gt;Posts\u0026lt;/button\u0026gt; \u0026lt;button onClick={() =\u0026gt; fetchUrl(\u0026#39;todos\u0026#39;)}\u0026gt;Todos\u0026lt;/button\u0026gt; \u0026lt;pre\u0026gt;{JSON.stringify(data, null, 2)}\u0026lt;/pre\u0026gt; \u0026lt;/div\u0026gt; ) } import { useFetch } from \u0026#39;hooks/useFetch\u0026#39; const baseUrl = \u0026#39;https://jsonplaceholder.typicode.com\u0026#39; function App() { const { data: userData, fetchUrl } = useFetch(baseUrl, \u0026#39;users\u0026#39;) const { data: postData, fetchUrl } = useFetch(baseUrl, \u0026#39;posts\u0026#39;) const { data: todoData, fetchUrl } = useFetch(baseUrl, \u0026#39;todos\u0026#39;) return ( \u0026lt;div\u0026gt;{userData ? \u0026lt;pre\u0026gt;{JSON.stringify(userData[0], null, 2)}\u0026lt;/pre\u0026gt; : null}\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;{postData ? \u0026lt;pre\u0026gt;{JSON.stringify(postData[0], null, 2)}\u0026lt;/pre\u0026gt; : null}\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;{todoData ? \u0026lt;pre\u0026gt;{JSON.stringify(todoData[0], null, 2)}\u0026lt;/pre\u0026gt; : null}\u0026lt;/div\u0026gt; ) } ","permalink":"https://findmytrueself.github.io/ko/frontend/reactcustomhooks/","tags":null,"title":"React Custom hooks 정확한 이해"},{"categories":null,"content":"커리어 성장\n제일 먼저 생각 나던 단어이다.\n개발자로 지내면서 가장 두려운건 정체되어있는 것이다.\n요즘 자꾸 그런 기분이 들어, 일단 블로그를 다시 살려, 꾸준히 작성하려고 한다.\n기존 노션에 작성되었던 블로그를 하나씩 수정하며, 옮겨 나가고,\nMedium의 새로운 주제의 글을 많이 참조하며, 내것으로 만들어야겠다.\n코드도 아마추어같이 작성하지 않아야하고, 좀더 깊이 생각하고, 깔끔하게 작성하는 것을 목표해야겠다.\n취미\n사실 하고 싶은 건 많은데 아둥바둥 살아오며 이것저것 현실적인 문제를 생각하다 보니 자연스럽게 못하고, 가볍게 집에서 할 수 있는 취미만 고집하고 있었다.\n많은 액티비티한 취미들은 차가 필요하고 돈이 필요하다.\n친구 게븐이 놀러왔을 때 스노우보드를 처음으로 타봤는데 완전 재밌었다. 앞으로 새로운 취미로써 종종 탈 생각이다.\n혼자는 가능하다. 나는 오토바이가 있기 때문에, 가까운 스키장(대략 30km)에 가서 즐길 수 있다! 문제는 돈.\n피아노\n재작년에 사놓은 디지털 피아노가 있다. 악기 하나정도는 다룰줄 알아야지라는 마음이 있는데, 나는 피아노를 잘 치면 좋겠다.\n어릴 때 무작정 배운 피아노라 이론적인 부분 다 까먹고, 이제는 악보를 통째로 외워서 손에 익히는 방법으로 치고 있다.\n그래서 처음 배우기가 너무 어렵고 연습 방법 또한 노가다이다.\n모든 일에는 끈기가 중요한 것 같다. 꾸준히 조금씩 해나가야 하는게 목표이다.\n돈\n내년까지는 매달 100 이상 숨만 쉬어도 나간다. 버텨야한다.\n물가는 계속 올라서 매달 쓸 수 있는 돈이 한계가 있다.\n여기서 적금 좀더 넣어버리면.. 정말 없다.\n코드XXXX 불공정 계약이 어떻게 상황이 좋아질 수 있으면 좋겠지만.. 잔인하지만 자본주의에서 무식하면 당하는거다.\n다시 불장이 와서 자산이 그래도 좀 늘어났으면 좋겠다.\n운동\n작년에 헬스장을 끊어놓고 반년 이상은 통째로 날려버렸다.. 너무 무기력하다.\n돈도 너무 아깝고, 그동안 생긴 근손실은 어떻게 다시 복구 할건지 걱정이다.\n집주변에 또 운동할만한 곳이 마땅히 없어서 꾸준히 다니기에 또 쉽지 않을 것 같다.\n","permalink":"https://findmytrueself.github.io/ko/diary/2023goal/","tags":null,"title":"2023 목표"},{"categories":null,"content":"다사다난 했었던 1년이 이제 곧 지나간다.\n서른살이 되던 21년, 정말 마지막이라고 생각하고, 개발자로 전향을 목표로 목숨을 걸며, 1년간 치열히 살았던 기억밖에 없다.\n그리고 22년 올해가 시작되는 1월, 적성에 맞는 적절한 직업을 찾게 되었다.\n중국 왔다갔다하며 쓰던, 27인치 캐리어에 옷가지 몇벌과 취업 축하한다고 어머니께서 사주신 깔끔한 코트 한벌 들고 상경했다.\n아무것도 없었던 나는, 새로운 환경에 적응 하는데 꽤 시간이 걸렸고, 스스로의 노력이 필요했다.\n처음에는 긴장의 연속이었지만, 점점 나아졌다. 그 속에는 나를 좋아해주는 좋은 동료들이 있었다.\n회사 다니면서, 먹고산다는 핑계로 많은 것을 손 놓고 지냈던 것 같다.\n일도 그렇고 22년 후반기에는 자기개발도 많이 없었다.\n개발 할 때도 두번, 세번 생각하고 코드를 쳐야 하는데, 빨리빨리 대충 개발 하려고 했었다.\n또, 지나간 코드를 다듬는 시간도 필요 했는데, 그런게 많이 부족했다.\n돈\n취직에 성공하며, 월급을 받아 잠시나마 행복했지만 깨달은 점은 월급쟁이는 항상 쪼들리며 사는 것 같다.\n투자만 안했어도, 근근히 적금들며 살았을 것 같다. 투자로 인한 손실이 꽤나 컸다.\n불장일때나 베어장일때나 마이너스인 나는 투자를 하면 안되는 것인가 싶다.\n불장일때 주린이 었던 나는 쉽게 투자를 성공했었고, 점점 담이 커져, 감당못할 레버리지도 사용했었고, 손실을 입었다.\n올해는 시작부터 베어장이었는데, 저점은 여전히 알 수 없다. 떨어질때마다 물 타던 계좌가 어느덧 모아둔 돈 대부분이 주식 코인 계좌에 가있다.\n위험 부담을 느낀 만큼 나는 부자가 될 것이다.\n첫이사 - 독립, 고생길시작\n아무것도 없었던 나는 상경하고 무작정 회사 근처 고시원으로 들어가야 겠다고 생각했다. 달리 방도가 없었다.\n차비라도 아껴보자 싶어, 회사 바로 앞에 있는 고시원을 알아봤다. 그것 또한 자리가 없어서 다른 곳을 알아봐야했다.\n알아보다 보니, 모란쪽에 되게 모양만 그럴싸하게 잘 꾸며놓은 고시원이 있었다. 짐싸들고 무작정 찾아갔다. 잘모르는 상태에서 방을 보지도 못했고, 이미 짐을 다 들고 나와서 달리 선택지가 없었다.\n첫 한달은 회사 적응하랴 고시원에서 생활하랴 버티고 또 버텼다.\n창문도 없는 1평짜리 방에서 잠시 지내며, 폐쇄공포증이 이런거구나 몸소 느꼈다.\n운좋게도 회사 바로 옆에 처음에 봤던 고시원에 자리가 났다고 했다. 근데 가격차이가 어마어마했다. 창문없는 방과 창문있는 방은 거의 월세 20만원 가까이 차이가났다.\n1달 살아본 결과 무조건 창문이 있는 방으로 가는게 맞다고 생각했고, 이사날 또 사건이 터졌다.\n1달 지내고 이제 퇴거 하려는데 공용공간에 맡겨둔 캐리어가 없어졌다.\n너무 열이 받아 범인을 꼭 찾아야겠다고 생각했다. 1달밖에 살지 않아서 퇴거한 인원이 몇명없어서 수사망을 좁히는데 성공했다.\ncctv기록은 뭐 거의 있으나 마나식으로 관리되고 있었다. 그래서, 그 몇명에게 고시원관리자가 연락해 자백을 받았다고한다. (자백이라기 보다는 실수로 가져갔다는 말도 안되는 소리를 했다.)\n한 스무살 정도로 보이는 애였는데, 끝까지 건방진 태도를 봐서 정말 처벌하고 싶었는데, 마음이 약해져 또 그냥 넘어가줬다.\n두번째이사 - 전세 구하기 여정\n두번째 집은 한 2~3평정도 되는 화장실이 포함된 원룸텔이었다. 조금 넓어지고 창문이 생겼다고, 숨통이 좀 트였다.\n하지만 이곳도 불편한건 마찬가지였다. 고시원장이 되게 까탈스러워서 내내 상주하며 짜증을 내는 소리를 들어야했다.\n여전히 전화도 마음대로 못하고 답답하게 지내야했다. 빨리 이사를 하고 싶었는데, 이제는 웬만하면 전세로 가고 싶어서, 몇개월동안 회사다니며 전세집을 알아보고 다녔다.\n이 건물이 또 상가건물이라 엘레베이터에서 수많은 사람들이랑 마주친다. 이때 코로나를 걸렸다.\n처음에는 월급도 받고 Flex한다고 근처에 매번 먹으러 다녔다.\n그쪽 근처가 물가가 다 비싸서 맨날 사먹고 다니니 남는게 하나도 없었다.\n뭔가 박봉은 아닌거같은데 세상이 나를 박봉화 시킨다.\n최대한 아껴보자 싶어 간단히 해먹을 수 있는 음식들을 쟁여놓고 먹었다.\n가끔은 공용공간에서 고기를 구워먹었는데 또 고시원장이 눈치를 많이 줬다. 고시원장 때문에라도 빨리 나가고싶었다.\n돌이켜보면, 이때 당시가 부동산 폭등의 정점이었을 때라서 전세가격이 어디든 너무 높았다.\n일반적인 전세를 가기에는 갖고있는게 너무나 없었다.\n그래서 21년도에 LH청년전세대출에 당첨되어 있어서, 그 방법 밖에 전세 구할 방법이 없었다. 하지만, LH권리심사가 엄청나게 까다롭다.\n대부분 대출을 많이 끼고 집들을 매매하기 때문에, 웬만한 집들은 LH로 들어가기 힘들다. 20~30년 된 오래된 구축 빌라들만 가능하다고 보면 된다.\n이때 돌아다니고 출퇴근 편하려고 작은 오토바이 하나 샀다. 연비가 1리터에 60km를 간다고한다. 요즘은 날도 춥고 위험해서 잘 안탄다.\n오토바이 타고 봄 ~ 여름에 집보러 다니며 많이 돌아다녔다. 경기남부 지역은 웬만한 곳은 대부분 돌아본 것 같다.\n어떻게든 분당으로 집 구하고 싶었는데, 현실적으로 불가능했다. 그렇게 해서 내려가다 보니 수원까지 갔다.\n머리를 좀 굴려봤다. 어떻게 하면 신분당선을 타고 출퇴근 할 수 있을까 싶었다.\n역 앞은 너무 비싸서, 버스타고 역 앞까지 갈 수 있는 최적의 동선을 찾았다.\n운좋게 리모델링 하는 LH대출 가능한 전세집을 찾게 되었고, 도배가 안되어있었는데 딱보니 구조도 괜찮은 것 같아 계약을 했다. 2룸에 14평이었다.\n두번째 이사를 하고 세달정도 걸렸던 것 같다.\n세번째 이사\n이사 전에 빈집이었기 때문에, 오토바이로 짐을 조금씩 여러차례 옮겨놨다.\n오래된 빌라 촌의 귀신나올 것 같은 비쥬얼이지만 나름 안에는 잘 꾸며놨다. 전세집이다보니 가전 가구 하나도 없었기 때문에 직접 다 샀다.\n이사 이후로 한동안 하나씩 맞춰가는 재미도 있었다. 당근에서 가져온 것들이 많았고, 세탁기같은 웬만한 가전은 찝찝하기도 하고 용달비 이런거 생각하니 그냥 새로 샀다.\n오래된 건물이라 벌레나 단열 문제가 걱정이 되긴 했다. 요즘 추위는 창문에 뽁뽁이 붙여놓는다고 해결 될 문제가 아니었다. 그래도 살아야하니 문풍지나 이것저것 또 붙여야겠다.\n그래도 내 공간이 많아져서 집에 있으면 나름 편안하다. 항상 생각하지만, 그 상황에서는 최선이었다.\n목표는 이 집에서 오래 살다가 돈을 모아서 매매하는게 목표이긴한데, 돈모으기가 쉽지않다.\n월급날만 되면 이놈 저놈 가져가버린다. 자본주의 양아치들이랑 함께 사는게 그렇게 쉽지않다.\n코로나 종결?\n코로나는 끝이 없었다.\n19년 12월에 어느 뉴스를 보고 포스팅한게 생각이 난다. 워낙 가짜뉴스들이 많아, 21세기에 무슨 중세시대 페스트같은 전염병이라니 말도 안된다고 생각했다.\n그런데 진짜였고.. 그게 22년도가 지나고 있는 지금도 끝나지 않았다.\n올해 초에 한국은 실질적으로 위드코로나를 실시하여 나도 한번 걸려서 죽다살았다.\n3차까지 맞은 백신 이후 1주일 채 되지 않아 걸렸기 때문에 백신에 대해 의문이 들긴했었다.\n중국은 이제서야 위드코로나를 한다고 하여, 벌써 절반이상이 걸렸다고 한다. 주가도 다시 올라가고, 빨리 모든게 정상화 되길 바란다.\n회고\n내가 올해 1년간 많은 성장을 했나 물어본다면 반은 맞고 반은 틀린 것 같다.\n올해는 정말 생존을 위해 고군분투 한 기억 밖에 없다. 사실상 불안정하고, 가장 힘든 시기이지 않을까 싶다.\n그래도 운이 좋아서 지금까지 버텼고, 또 최악의 상황에 맞춰서 잘 살아가고 있는 것 같다.\n개발자로써의 커리어도 잡으려면 당장의 걱정을 접어두고, 좀더 마음의 여유를 갖고 지내야하지 않을까 싶다.\n","permalink":"https://findmytrueself.github.io/ko/diary/2022retrospect/","tags":null,"title":"2022년 회고"},{"categories":null,"content":" createAsyncThunk는 비동기 작업을 처리하는 Action을 만들어준다. const asyncUpFetch = createAsyncThunk(\u0026#39;counterSlice/asyncUpFetch\u0026#39;, async () =\u0026gt; { const resp = await fetch(\u0026#39;https://api.aergo.io/~~\u0026#39;) const data = await resp.json() return data.value }) createAsyncThunk Flow reducers를 사용하면, actionCreator를 툴킷이 자동으로 만들어주지만, 비동기작업에서는 actionCreator를 자동으로 만들어주지 못하기 때문에, extraReducers에 직접 만들어 주어야 한다. ","permalink":"https://findmytrueself.github.io/ko/frontend/reduxthunk/","tags":["Javascript","React"],"title":"Redux Thunk 정리"},{"categories":null,"content":"\u0026lt;Button variant=\u0026#34;contained\u0026#34; component=\u0026#34;label\u0026#34;\u0026gt; 아이콘 업로드 \u0026lt;input accept=\u0026#34;image/*\u0026#34; multiple type=\u0026#34;file\u0026#34; hidden onChange={(e: ChangeEvent\u0026lt;HTMLInputElement\u0026gt;): void =\u0026gt; handleUploadIcon(e)} /\u0026gt; \u0026lt;/Button\u0026gt; 먼저, 업로드 버튼을 만들고, 모든이미지를 허용하고, file타입으로 input태그를 만든다.\nconst handleUploadIcon = (e: ChangeEvent\u0026lt;HTMLInputElement\u0026gt;) =\u0026gt; { setImgFile(e.target.files[0]) const imagePromise = e.target.files[0].arrayBuffer().then((buf) =\u0026gt; { return makeImage(buf, figure, borderColor) }) imagePromise.then((resized) =\u0026gt; { const fileReader = new FileReader() fileReader.readAsDataURL(resized) fileReader.onload = (e) =\u0026gt; { const image = new Image() image.src = e.target.result as string image.onload = () =\u0026gt; { const base64Img = e.target.result as string // //! 아이콘 해쉬 변환 const hash = CryptoJS.SHA256(base64Img).toString() const file = dataURLtoFile(base64Img, \u0026#39;MaskedImage.png\u0026#39;) dispatch(setInfo(base64Img, \u0026#39;base64Img\u0026#39;)) dispatch(setInfo(hash, \u0026#39;아이콘 추가\u0026#39;)) setFile(file) } } }) } makeImage함수로 이미지를 masking 그리고, dataURLtoFile 함수로 파일객체로 만들어준다.\nuseEffect(() =\u0026gt; { if (imgFile) { const imagePromise = imgFile.arrayBuffer().then((buf: ArrayBuffer) =\u0026gt; { return makeImage(buf, figure, borderColor) }) imagePromise.then((resized: Blob) =\u0026gt; { const fileReader = new FileReader() fileReader.readAsDataURL(resized) fileReader.onload = (e) =\u0026gt; { const image = new Image() image.src = e.target.result as string image.onload = () =\u0026gt; { const base64Img = e.target.result as string const hash = CryptoJS.SHA256(base64Img).toString() const file = dataURLtoFile(base64Img, \u0026#39;MaskedImage.png\u0026#39;) dispatch(setInfo(base64Img, \u0026#39;base64Img\u0026#39;)) dispatch(setInfo(hash, \u0026#39;아이콘 추가\u0026#39;)) setFile(file) } } }) } }, [borderImgState, borderColor]) useEffect(() =\u0026gt; { if (icon \u0026amp;\u0026amp; file) { dispatch(setInfo(file, \u0026#39;uploadFile\u0026#39;)) dispatch(setInfo(borderImg, \u0026#39;borderImgState\u0026#39;)) dispatch(setInfo(borderColor, \u0026#39;borderColor\u0026#39;)) } }, [icon, file]) border가 바뀔때마다, 그리고 img가 바뀔때마다, masking 함수를 실행한다.\n/* eslint-disable func-names */ /* eslint-disable no-bitwise */ /* eslint-disable no-plusplus */ import { Image as ImageJS } from \u0026#39;image-js\u0026#39; import { lineURL, pngURL } from \u0026#39;../../components/TokenDeploy/MakeSymbol\u0026#39; const BASE_SIZE = 640 async function makeImage( imgBytes: ArrayBuffer, templateNum: number, borderColor: string ) { // 1. load image from bytes const originalImg = await ImageJS.load(imgBytes) const emptyArr = new Array(640 * 640 * 4).fill(0) const bg = new ImageJS(BASE_SIZE, BASE_SIZE, emptyArr, { alpha: 1 }) console.log( \u0026#39;original originalImg info\u0026#39;, originalImg.width, originalImg.height ) // 2. resize image let xOffset = 0 let yOffset = 0 let resizedImg: ImageJS if (originalImg.width \u0026gt; originalImg.height) { resizedImg = originalImg.resize({ width: BASE_SIZE }) yOffset = (BASE_SIZE - resizedImg.height) / 2 } else { resizedImg = originalImg.resize({ height: BASE_SIZE }) xOffset = (BASE_SIZE - resizedImg.width) / 2 } const squaredImg = await mergeImages(bg, xOffset, yOffset, resizedImg) // 3. make maskImage const maskOriginal = await makeMaskImage(templateNum) const mask: ImageJS = maskOriginal // @ts-ignore .gray() .mask({ threshold: 0.1, useAlpha: true }) // 4. extract by mask // @ts-ignore const maskedImage = await squaredImg.extract(mask, { position: [0, 0] }) // 5. draw border image const borderImg = await makeBorderImage(templateNum, borderColor) const borderAddedImage = await mergeImages(maskedImage, 0, 0, borderImg) // blob 타입으로 리턴 return borderAddedImage.toBlob() } async function makeMaskImage(templateNumber: number): Promise\u0026lt;ImageJS\u0026gt; { const borderMaskFile = pngURL[templateNumber] const maskUrl = `${borderMaskFile}` return new Promise\u0026lt;ImageJS\u0026gt;(function (resolve, reject) { const xhr = new XMLHttpRequest() xhr.open(\u0026#39;get\u0026#39;, maskUrl) xhr.responseType = \u0026#39;arraybuffer\u0026#39; xhr.onload = function () { ImageJS.load(xhr.response).then((mask) =\u0026gt; resolve(mask)) } xhr.onerror = function () { reject(new Error(`failed by ${this.status}`)) } xhr.send() }) } // * 색칠. async function makeBorderImage( templateNumber: number, borderColor: string ): Promise\u0026lt;ImageJS\u0026gt; { const rawBorderMask = await loadBorderImage(templateNumber) // @ts-ignore const mask = rawBorderMask.gray().mask({ threshold: 0.1, useAlpha: true }) const background = new ImageJS(BASE_SIZE, BASE_SIZE, [], { alpha: 1 }) // @ts-ignore const maskedBorder = background.extract(mask, { position: [0, 0] }) const border = maskedBorder.paintMasks(mask, { color: borderColor }) return border } // * 이미지로드. async function loadBorderImage(templateNumber: number): Promise\u0026lt;ImageJS\u0026gt; { const borderMaskFile = lineURL[templateNumber] const borderUrl = `${borderMaskFile}` return new Promise\u0026lt;ImageJS\u0026gt;(function (resolve, reject) { const xhr = new XMLHttpRequest() xhr.open(\u0026#39;get\u0026#39;, borderUrl) xhr.responseType = \u0026#39;arraybuffer\u0026#39; xhr.onload = function () { ImageJS.load(xhr.response).then((mask) =\u0026gt; resolve(mask)) } xhr.onerror = function () { reject(new Error(`failed by ${this.status}`)) } xhr.send() }) } async function mergeImages( out: ImageJS, x: number, y: number, toInsert: ImageJS ) { const maxY = Math.min(out.height, y + toInsert.height) const maxX = Math.min(out.width, x + toInsert.width) if (out.bitDepth === 1) { for (let j = y; j \u0026lt; maxY; j++) { for (let i = x; i \u0026lt; maxX; i++) { const val = toInsert.getBitXY(i - x, j - y) if (val) out.setBitXY(i, j) else out.clearBitXY(i, j) } } } else { for (let j = y; j \u0026lt; maxY; j++) { for (let i = x; i \u0026lt; maxX; i++) { if (toInsert.getPixelXY(i - x, j - y)[3] \u0026gt; 127) { out.setPixelXY(i, j, toInsert.getPixelXY(i - x, j - y)) } } } } return out } export default makeImage const dataURLtoFile = (base64: string, fileName: string) =\u0026gt; { const arr = base64.split(\u0026#39;,\u0026#39;) const mime = arr[0].match(/:(.*?);/)[1] const bstr = window.atob(arr[1]) let n = bstr.length const u8arr = new Uint8Array(n) while (n--) { u8arr[n] = bstr.charCodeAt(n) } const file = new File([u8arr], `${fileName}.png`, { type: mime }) return file } ","permalink":"https://findmytrueself.github.io/ko/frontend/imgmask/","tags":["Javascript","React"],"title":"리액트에서 이미지 마스킹하기"},{"categories":null,"content":"요즘 현실은 월급을 받고 일을하려면 수도권에 와야한다.\n아니면, 공기업을 가던가 자영업을 하던가.. 일용직이나 알바를 하던가이다.\n그래서 나같은 사람들은 되게 수도권을 와야만 먹고산다. 하지만, 나는 전혀 수도권에 연고가 없다.\n결국 먹고 사려면 수도권에서 자리를 잡아야하는데, 그때부터는 이제 주거문제로 항상 골머리를 싸매야한다.\n살기 위해서\n한달 고정 지출을 생각 해 보았는가?\n그중에 가장 큰 주거비용은 정말 숨만쉬어도 나가는 돈이다.\n사실 우리가 돈을 버는 이유는 무엇인가?\n나는 더 나은 삶의 질을 찾기 위해서 돈을 번다고 생각한다.\n목돈을 마련해야만 삶의 질을 올릴수가 있는데, 여기서는 숨만쉬어도 돈이 나간다.\n돈을 벌기는 쉽지 않지만, 돈을 쓰기는 너무나도 쉽다.\nLH전세대출을 받은 계기\n2021년 한창 개발공부를 할 때, 그때도 어떻게 하면 앞으로 좀더 저렴하게 나은집을 살수있을까 고민하며 사이트를 들락날락 거렸다.\n그중에 마포에있는 행복주택을 1차로 신청하고, 2차로 LH 3순위를 신청했다.\n마포에있는 행복주택은 당연히 수도권이나 같은 지역구 사람들에게 밀릴것이라고 판단하여, 쉐어형으로 신청했었다.\nLH는 운좋게도 3순위 전형이 있어서, 소득이 책정이 안되어있던 나는 청년 혹은 취업준비생으로 운좋게 신청할 수 있었다.\n그러고는 몇달 간 소식이 없었다.\n그때까지는 이미 취업도 되어있는 상태였고, 여러 고시원을 옮겨다니며 전전긍긍 하고 있었다.\n정말 절망적인건 고시원이라고 해서 월세가 싼 것도 아니었다.\n집은 어떻게 구하러 다녔나요?\n현재 다니는 회사가 분당에 있어서, 기존에 마포에 신청했던 행복주택은 되도 갈까 고민하고 있는 찰나에.. 심사 중에 소득이 생겨버려서 행복주택도 명단에서 제외되었다.\n나머지는 LH전세대출이나 일반 청년전세자금대출 혹은 디딤돌전세대출 같은 제도만 가능했다.\n사실 100% 모두 나오는 전세대출은 LH전세대출과 중소기업청년대출밖에 없다.\n정말 아이러니 한 것은 그런 100%를 대출 나오는 방을 찾기는 하늘에 별따기 보다 힘들었다.\n딱 봤을때 괜찮아보이는 집은 전부 안된다고 보면 된다.\n그래서, 회사 다니면서 시간을 짜내면서 오토바이를 타고 집보러 경기남부는 거의 모두 돌아다녔다고 보면 된다.\n최대한 분당에서 집을 구하고 싶었지만.. 분당에서 LH나 중기청은 수요가 너무 많아서 거의 모두 안된다고 보면되고, 다른 대출을 받기에는, 금리가 계속 오르는 추세라 이자감당이 안될 것 같았고, 전세사기 또한 당할까봐 두려웠다.\n그래서, 나에게 선택지는 몇가지 없었다. 보증금 낮게 월세아니면 LH를 이용한 전세였다.\nLH전세대출의 좋은점\n전세사기를 당할 위험이 1도 없다.\n왜냐하면, 관련 대출금은 나와 집주인의 계약이 아닌, LH공사와 집주인과의 계약이기 때문이다.\n그래서 정말 마음높고 계약 할 수 있었다.\n권리분석만 승인이 나오면, 계약날 법무사님이 알아서 다 해주신다.\n전세금 100% 대출\n요즘에는 집값이 너무나 비싸니깐 1억에 80%만 대출받는다고 해도, 2000만원이 필요하다\n근데 웃긴건 대출가능한 전세 1억짜리 집은 그렇게 좋은 집이 없을 것이다.\n사실 이자 생각하면 월세랑 거의 다를게 없다.\n월세는 오히려 전세사기를 안당하니깐 더 이득일수도 있다..\nLH전세대출은 100% 대출이 나온다. 그리고 고정금리 2%이다. 각자 개인에따라 우대금리도 0.5%씩 적용된다.\nLH전세대출의 나쁜점\n딱봤을때 사람들이 살고싶지않은 집들을 살아야 한다.\n나의 오로지 주 목적은 월세를 최대한 줄이고자 였기 때문에.. 최대한 LH를 이용해야했었다.\n그래서 방 상태도 그냥 살만하면 들어가야겠다. 하고 방을 보러 다녔는데.. 웬걸.. 정말 충격적인 상태의 집들이 너무나 많았다.\n그런데 정말 그것 또한 없어서 못구한다. 너무 충격을 받아 사실 LH는 포기하고 있었다.\n방을 구하게 된 계기\n여러 동네를 다니면서 나는 그래도 신분당선에 가까운 곳으로 최대한 구하고자 노력했다.\n신분당선을 타면, 강남, 판교, 정자(회사), 광교까지 가고, 앞으로 노선도 확장이 되가고 있기 때문이었다.\n물론, 가격은 그마만큼 비싸지만, 그래도 신분당선을 탈때만큼은 삶의질이 향상된다.\n그래서 버스로 접근 가능한 지역의 방들을 보다가, 전면 리모델링이 진행중인 집을 발견했다.\n건물은 오래되었지만, 투룸에 내부는 깔끔하니 되어 있어서 지금 상황에서는 최선이라고 판단하고 바로 계약을 했다.\n반전세로 월세를 좀더 내고 살지만.. 그래도 못구하고 있는것보단 낫다고 판단하고 계약을 진행했다.\n옵션이 단, 하나도 없어서 다 직접 구해야한다. 그게 좀 단점이다.\n지금은 입주날을 기다리고 있는 상태이다. 출퇴근 시간은 늘어나겠지만.. 앞으로는 가끔은 재택근무를 하면서, 최대한 출퇴근 시간을 줄여보고자 한다.\n느낀점\n지금까지 살면서 대부분 아파트 생활만 해왔었기 때문에, 빌라의 불편함을 못느끼고 있지만, 앞으로 살아가면서 느끼게 될 것 같다.\n그래도, 내 스스로 집을 구했다는 것에 대해 자랑스럽게 생각한다.\n코드XXXX에서 가져가는 돈이 너무나 많아서, 월에 나가는 비용을 최대한 줄여야 하는 나의 최선이었다.\n공간이 늘어나서 당연히 삶의 질도 올라 갈 것이고, 집에서 할 수 있는 것도 많이 생길 것 같다.\nLH전세대출이 당첨되면 꼭 여러군데를 산삼(?)을 찾듯 돌아다녀보는 것도 하나의 재미가 될 수도 있겠다.\n","permalink":"https://findmytrueself.github.io/ko/diary/lh/","tags":null,"title":"LH전세대출로 집구하기"},{"categories":null,"content":"지금껏 프로젝트를 하면서, 리덕스를 사용하여 상태관리를 해왔다.\n상태관리 라이브러리는 정말 많다. 최근에 들어본 상태관리 라이브러리는 Mobx , Recoil, Zustand 등등..\n다른 상태관리를 직접 프로젝트에서 적용해보진 않았지만, 통계적으로 압도적이다.\n지금까지 리액트와 리덕스를 사용하면서 큰 불편함을 느낀적은 없었다.\n하지만, 리덕스의 타입정의, 액션함수, 리듀서를 왔다갔다 하며 변경해줘야하는 번거로움이 있었다.\n리액트 18버전으로 업그레이드 하면서, 기존에 내가 사용하던 리덕스의 문법이 Legacy한 문법이라고 하여 찾다보니 리덕스 툴킷이라는 라이브러리가 기존의 리덕스의 불편함을 보완 해줄 수 있다고 어렴풋하게 알고있었다.\n당시 개발하기 바쁘니깐, 꼼꼼하게 공식문서를 읽어보지 않고, 대충 블로그에서 찾은 방법 그대로 적용하려고 애썼다.\n결과적으로 기존의 리덕스 코드를 리팩터링하기에 실패하고,\n기존 리덕스 코드 또한 구조도 잘 갖추었고, 문제가 없다고 판단하여, 다시 기존 리덕스 코드로 돌아왔다.\n이번 새로운 프로젝트에는 리덕스 툴킷을 처음부터 사용해보고자, 정리하여 글로써 남겨본다.\n리덕스\nRedux is a state container The state of the application can change In redux, a pattern is enforced to ensure all state transitions are explicit and can be tracked The changes to your application\u0026rsquo;s state become predictable If you want to manage the global state of your application in a predictable way, redux can help you The patterns and tools provided by Redux make it easier to understand, when, where, why, and how the state in your application is being updated, and how your application logic will behave when those changes occur Redux guides you towords writing code that is predictable and testable, which helps give you confidence that your application will work as exected 리덕스 툴킷\nRedux toolkit is the officail, opinionated, batteries-included toolset for efficient Redux development. It is also intended to be the standard way to write Redux logic in your application 리덕스 툴킷을 쓰는 이유\nRedux is great, but it does have a few shortcomings, Configuring redux in an app seems complicated. In addition to redux, a lot of other packages have to be installed to get redux to do something useful. Redux requires too much boilerplate code Redux toolkit serves as an abstraction over redux. It hides the difficult parts ensuring you have a good developer experience. 언제 리덕스를 써야하는가?\nYou have large amounts of application state that are needed in many places in the app The app state is updated frequently over time The logic to update that state may be complex The app has a medium or large-sized codebase, and might be worked on by many people Immer 라이브러리\n리덕스 객체를 다룰때, immutable을 유지하기 위해 rest parameter 혹은 배열의 내장함수를 이용해서 불변성을 구현 할 수 있지만, 코드가 복잡해지는 단점이 있다.\nimmer가 이러한 불변성을 관리 해준다.\n세가지 컨셉\nstore : holds the state of your application. action : describes what happened in the application reducer : handles the action and decides how to update the state 리덕스툴킷 문법\n스토어 생성 import { configureStore } from \u0026#34;@reduxjs/toolkit\u0026#34;; // ... export const store = configureStore({ reducer: { posts: postsReducer, comments: commentsReducer, users: usersReducer, }, }); // Infer the `RootState` and `AppDispatch` types from the store itself export type RootState = ReturnType\u0026lt;typeof store.getState\u0026gt;; // Inferred type: {posts: PostsState, comments: CommentsState, users: UsersState} export type AppDispatch = typeof store.dispatch; 장점\nHooks사용매번 useDispatch와 useSelector를 선언할때 타입까지 상태 타입까지 설정해야하는 번거로운 문제가 있었다. hooks를 이용하여, 이러한 번거로운 코드를 없애자!! // hooks/index.ts import { TypedUseSelectorHook, useDispatch, useSelector } from \u0026#34;react-redux\u0026#34;; import type { RootState, AppDispatch } from \u0026#34;./store\u0026#34;; // Use throughout your app instead of plain `useDispatch` and `useSelector` export const useAppDispatch = () =\u0026gt; useDispatch\u0026lt;AppDispatch\u0026gt;(); export const useAppSelector: TypedUseSelectorHook\u0026lt;RootState\u0026gt; = useSelector; //? dispatch를 실행할 컴포넌트 import { useAppDispatch } from \u0026#34;hooks\u0026#34;; const dispatch = useAppDispatch(); dispatch(리듀서함수()); CreateSlice 문법 import { createSlice, PayloadAction } from \u0026#34;@reduxjs/toolkit\u0026#34;; import type { RootState } from \u0026#34;../../app/store\u0026#34;; // Define a type for the slice state interface CounterState { value: number; } // Define the initial state using that type const initialState: CounterState = { value: 0, }; export const counterSlice = createSlice({ name: \u0026#34;counter\u0026#34;, // `createSlice` will infer the state type from the `initialState` argument initialState, reducers: { increment: (state) =\u0026gt; { state.value += 1; }, decrement: (state) =\u0026gt; { state.value -= 1; }, // Use the PayloadAction type to declare the contents of `action.payload` incrementByAmount: (state, action: PayloadAction\u0026lt;number\u0026gt;) =\u0026gt; { state.value += action.payload; }, }, }); export const { increment, decrement, incrementByAmount } = counterSlice.actions; // Other code such as selectors can use the imported `RootState` type export const selectCount = (state: RootState) =\u0026gt; state.counter.value; export default counterSlice.reducer; 이후, 사용하고 싶은 action함수를 dispatch하면 된다.\n","permalink":"https://findmytrueself.github.io/ko/frontend/reduxtoolkit/","tags":["React"],"title":"리덕스툴킷 찍먹하기"},{"categories":null,"content":"Promise\n자바스크립트 ES6이후에 등장하게 된 promise객체는 비동기 처리 작업 할 때 콜백함수가 쌓이게되는 콜백지옥을 해결하기 위해 처음 등장이 되었다.\n같은 원리이지만, promise객체를 통해 더 가독성이 쉽게 표시할 수 있어서 이용하게 되었고,\npromise 또한 많은 promise변수를 사용하여 리턴하게 되면 promise지옥을 경험 할 수 있다.\n콜백함수, promise, async/await의 응답속도\n콜백함수나 promise의 응답속도는 거의 같다.\n처음 호이스팅 환경에서 차례로 읽기 때문에 비동기 처리 되는 영역은 처리 완료 되지 않은 상태에서 다음을 읽는다. 따라서, setTimeout함수와 같이 딜레이를 주게 되어도 응답속도는 딜레이를 무시하고 먼저 처리한다.\n콜백함수와 promise의 응답속도가 거의 같다고 하는 이유는, 브라우저의 환경 차이로 인해서 미세한 속도 차이가 발생 할 수 있다.\n전체응답속도는 async/await는 모든 비동기작업(setTimeout과 같은 딜레이 작업들)이 끝나고 순서대로 처리가 완료 된다. 따라서, 처리완료되는 속도는 가장 느리다고 할 수 있다.\n콜백함수\n콜백함수를 이해하기 위해서는 먼저 \u0026lsquo;호이스팅\u0026rsquo;에 대해 이해 해야 한다.\n호이스팅\n함수 안에 있는 선언들을 모두 끌어올려서 해당 함수 유효범위의 최상단에 선언하는 것.\n함수가 실행되기 전에 함수에 필요한 모든 값을 최상단에 선언한다.\nsetTimeout(callback , time)\n브라우저 API\ncallback 함수를 time(ms단위) 이후 출력한다.\n동기(Synchronous)와 비동기(Asynchronous)\n자바스크립트는 Synchronous 이다.\nSynchronous callback\nconsole.log(\u0026#39;1\u0026#39;) setTimeout(() =\u0026gt; console.log(\u0026#39;2\u0026#39;), 1000) console.log(\u0026#39;3\u0026#39;) function printImmediately(print) { print() } printImmediately(() =\u0026gt; console.log(\u0026#39;hello\u0026#39;)) 호이스팅 결과.\nfunction printImmediately(print) { // 1. 호이스팅 함수선언문 print() } console.log(\u0026#39;1\u0026#39;) // 2. \u0026#39;1\u0026#39; 출력 setTimeout(() =\u0026gt; console.log(\u0026#39;2\u0026#39;), 1000) // 3. 브라우저API에 1초후에 \u0026#39;2\u0026#39; 출력 요청 console.log(\u0026#39;3\u0026#39;) // 4. \u0026#39;3\u0026#39; 출력 printImmediately(() =\u0026gt; console.log(\u0026#39;hello\u0026#39;)) // 5. 함수 즉시출력 실행 \u0026#39;hello\u0026#39; 출력 // 6. 1초 후, 브라우저API에 의해 \u0026#39;2\u0026#39; 출력 Asynchronous callback\nconsole.log(\u0026#39;1\u0026#39;) setTimeout(() =\u0026gt; console.log(\u0026#39;2\u0026#39;), 1000) console.log(\u0026#39;3\u0026#39;) function printImmediately(print) { print() } printImmediately(() =\u0026gt; console.log(\u0026#39;hello\u0026#39;)) function printWithDelay(print, timeout) { setTimeout(print, timeout) } printWithDelay(() =\u0026gt; console.log(\u0026#39;async callback\u0026#39;), 2000) 호이스팅 결과호이스팅 결과\nfunction printImmediately(print) { print() } function printWithDelay(print, timeout) { setTimeout(print, timeout) } console.log(\u0026#39;1\u0026#39;) // 동기 setTimeout(() =\u0026gt; console.log(\u0026#39;2\u0026#39;), 1000) // 비동기------------\u0026gt; console.log(\u0026#39;3\u0026#39;) // 동기 printImmediately(() =\u0026gt; console.log(\u0026#39;hello\u0026#39;)) // 동기 printWithDelay(() =\u0026gt; console.log(\u0026#39;async callback\u0026#39;), 2000) // 비동기 -------------\u0026gt; Promise\nPromise는 \u0026ldquo;비동기 상태를 값으로 다룰 수 있는 객체\u0026rdquo;\nPromise가 왜 필요한가요?\n프로미스는 주로 서버에서 받아온 데이터를 화면에 표시할 때 사용합니다. 일반적으로 웹 애플리케이션을 구현할 때 서버에서 데이터를 요청하고 받아오기 위해 API를 사용합니다.\n콜백 패턴의 문제\n콜백 함수의 중첩 사용 function requestData1(callback) { callback(data) // 2 } function requestData2(callback) { callback(data) // 4 } function onSuccess1(data) { console.log(data) requestData2(onSuccess2) // 3 } function onSuccess2(data) { // 5 console.log(data) } requestData1(onSuccess1) // 1 // 콜백 패턴의 코드의 흐름이 순차적이지 않기 때문에, 코드를 읽기가 힘들다. 간단한 프로미스 코드 예 requestData1() .then((data) =\u0026gt; { console.log(data) return requestData2() }) .then((data) =\u0026gt; { console.log(data) }) 프로미스의 세 가지 상태 pending : 대기 fulfilled : 수행이 정상적으로 끝났고 결과값 존재 rejected : 수행이 비정상적으로 끝났음. settled : 이행됨 , 거부됨 상태프로미스는 처리 됨 상태가 되면 더 이상 다른 상태로 변경되지 않는다. 대기 중 상태일 때만 이행됨 또는 거부됨 상태로 변할 수 있다. 프로미스를 생성하는 방법 const p1 = new Promise((resolve, reject) =\u0026gt; { resolve(data) // or reject(\u0026#39;error message\u0026#39;) }) const p2 = Promise.reject(\u0026#39;error message\u0026#39;) const p3 = Promise.resolve(param) Promise.resolve 반환 값 const p1 = Promise.resolve(123) console.log(p1 !== 123) // true 이행됨 상태인 프로미스가 반환된다. const p2 = new Promise((resolve) =\u0026gt; setTimeout(() =\u0026gt; resolve(10), 1)) console.log(Promise.resolve(p2) === p2) // true // Promise.resolve 함수에 프로미스가 입력되면 그 자신이 반환된다. 프로미스 이용하기 .then then은 처리 됨 상태가 된 프로미스 처리 할 때 사용되는 메서드. //requestData().then(onResolve, onReject); // 프로미스 처리됨 상태가 되면, onResolve 함수가 호출되고, 거부됨 상태가 되면 onReject 함수가 호출 된다. Promise.resolve(123).then((data) =\u0026gt; console.log(data)) // 123 Promise.reject(\u0026#39;err\u0026#39;).then(null, (error) =\u0026gt; console.log(error)) // err 연속해서 then 메서드 호출하기 let requestData1 = new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { resolve(\u0026#39;hun\u0026#39;) }, 1000) }) let requestData2 = new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { resolve(\u0026#39;jenny\u0026#39;) }, 2000) }) requestData1 .then((data) =\u0026gt; { console.log(data) return requestData2 // 1 }) .then((data) =\u0026gt; { return data + 1 // 2 }) .then((data) =\u0026gt; { throw new Error(\u0026#39;some Error\u0026#39;) // 3 }) .then(null, (error) =\u0026gt; { console.log(error) }) 함수에서 프로미스를 반환하면 then메서드는 그 값을 그대로 반환한다.\n프로미스가 아닌 값을 반환하면, then 메서드는 이행됨 상태인 프로미스를 반환한다.\n함수 내부에서 예외가 발생하면 then 메서드는 거부됨 상태인 프로미스를 반환한다.\n거부됨 상태가 되면 onReject 함수를 호출한다.\nPromise.reject(\u0026#39;err\u0026#39;) .then(() =\u0026gt; console.log(\u0026#39;then 1\u0026#39;)) // 1번 .then(() =\u0026gt; console.log(\u0026#39;then 2\u0026#39;)) // 1번 .then( () =\u0026gt; console.log(\u0026#39;then 3\u0026#39;), () =\u0026gt; console.log(\u0026#39;then 4\u0026#39;) ) // 2번 .then( () =\u0026gt; console.log(\u0026#39;then 5\u0026#39;), () =\u0026gt; console.log(\u0026#39;then 6\u0026#39;) ) // 3번 거부 됨 상태인 프로미스는 처음으로 만나는 onReject 함수를 호출 하므로 1번 이 생략되고, 2번 코드의 then 4가 출력 된다. then 4를 출력하는 함수는 undefined 를 결과로 가지면서 이행됨 상태인 프로미스를 생성한다. 3번 따라서 이어지는 then 메서드에서는 then 5가 출력된다. then 메서드의 가장 중요한 특징은 항상 연결된 순서대로 호출된다는 점이다.\n프로미스 이용하기 2 : catch catch는 프로미스 수행 중 발생한 예외를 처리하는 메서드이다. catch메서드는 then 메서드의 onReject 함수와 같은 역할을 한다. Promise.reject(1).then(null, (error) =\u0026gt; { console.log(error) }) Promise.reject(1).catch((error) =\u0026gt; { console.log(error) }) 예외 처리는 then메서드의 onReject를 이용하기보다는, catch메서드를 이용하는게 가독성 면에서 좋다.\nthen 메서드의 onReject를 사용했을 때 문제점. Promise.resolve().then( () =\u0026gt; { // 1번 throw new Error(\u0026#39;some error\u0026#39;) }, (error) =\u0026gt; { // 2번 console.log(error) } ) 1번 then 메서드의 resolve 함수에서 발생한 예외는 같은 then 메서드의 2번 reject함수에서 처리되지 않는다. 실행하면 Unhandled promise rejection 에러가 발생한다. 거부됨 상태인 프로미스를 처리하지 않았기 때문이다.\nonReject 함수를 사용하지 않고 catch를 사용한 예 Promise.resolve() .then(() =\u0026gt; { throw new Error(\u0026#39;some error\u0026#39;) }) .catch((error) =\u0026gt; { console.log(error) }) catch 메서드 이후에도 then 메서드 사용하기 Promise.reject(10) .then((data) =\u0026gt; { console.log(\u0026#39;then1:\u0026#39;, data) return 20 }) .catch((error) =\u0026gt; { console.log(\u0026#39;catch:\u0026#39;, error) return 30 }) .then((data) =\u0026gt; { console.log(\u0026#39;then2:\u0026#39;, data) }) // catch: 10 // then2: 30 프로미스 이용하기 3 : finally\nfinally를 사용한 간단한 코드 requestData() .then(data =\u0026gt; { ... }) .catch(error =\u0026gt; { ... }) .finally(() =\u0026gt; { ... }); finally 메서드는 새로운 프로미스를 생성하지 않는다. function requestData(){ return fetch() .catch(error =\u0026gt; { ... }) .finally(() =\u0026gt; { senLogToServer(\u0026#39;requestData finished\u0026#39;) }) } requestData().then(data =\u0026gt; console.log(data)); // 1번 1번, requestData 함수의 반환값은 finally 메서드 호출 이전의 프로미스다. 따라서, requestData함수를 사용하는 입장에서는 finally 메서드 존재 여부를 신경 쓰지 않아도 된다.\n프로미스 활용하기\n병렬로 처리하기 : Promise.all\nPromise.all은 여러 개의 프로미스를 병렬로 처리할 때 사용되는 함수이다. then 메서드를 체인으로 연결하면 각각 비동기 처리가 병렬로 처리되지 않는 단점을 극복한다.\n순차적으로 실행되는 비동기 코드 requestData1() .then((data) =\u0026gt; { console.log(data) return requestData2() }) .then((data) =\u0026gt; { console.log(data) }) 비동기 함수 간에 서로 의존성이 없다면, 병렬로 처리하는게 더 빠르다. then 메서드를 체인으로 연결하지 않고, 비동기함수를 각각 호출하면, 병렬로 처리 된다.\n병렬로 실행 되는 코드 requestData1().then((data) =\u0026gt; { console.log(data) }) requestData2().then((data) =\u0026gt; { console.log(data) }) requestData1과 requestData2는 동시에 실행 된다. 여러 프로미스를 병렬로 처리하고 싶을 경우 Promise.all을 사용하자.\nPromise.all 을 사용하는 코드 Promise.all([requestData1(), requestData2()]).then(([data1, data2]) =\u0026gt; { console.log(data1, data2) }) Promise.all 함수는 프로미스를 반환한다. Promise.all 함수가 반환하는 프로미스는 입력된 모든 프로미스가 처리됨 상태가 되어야 마찬가지로 처리됨 상태가 된다. 만약 하나가 거부됨 상태가 된다면, Promise.all 함수가 반환하는 프로미스도 거부됨 상태가 된다.\n가장 빨리 처리된 프로미스 가져오기 : Promise.race\nPromise.race 함수에 입력된 여러 프로미스 중에서 하나라도 처리됨 상태가 되면, Promise.race 함수가 반환하는 프로미스도 처리됨 상태가 된다.\nPromise.race를 사용한 간단한 코드 Promise.race([ requestData(), new Promise((_, reject) =\u0026gt; setTimeout(reject, 3000)), ]) .then((data) =\u0026gt; console.log(data)) .catch((error) =\u0026gt; console.log(error)) requestData 함수가 3초안에 데이터를 받으면 then메서드가 호출되고 그렇지 않으면 catch 메서드가 호출 된다.\n프로미스를 이용한 데이터 캐싱\n처리됨 상태가 되면, 그 상태를 유지하는 프로미스의 성질을 이용해서 데이터를 캐싱할 수 있다.\n프로미스로 캐싱 기능 구현하기. let cachedPromise function getData() { cachedPromise = cachedPromise || requestData() // 1번 return cachedPromise } getData().then((v) =\u0026gt; console.log(v)) getData().then((v) =\u0026gt; console.log(v)) 1번 getData 함수를 처음 호출 할 때만, requestData가 호출된다. 데이터를 가져오는 작업이 끝나면, 그 결과는 cachedPromise 프로미스에 저장된다.\n프로미스 사용 시 주의 할 점\nreturn 키워드 깜빡하지 않기. then 메서드 내부 함수에서 return 키워드를 입력하는 것을 깜빡하기 쉽다. then 메서드가 반환하는 프로미스 객체의 데이터는 내부함수가 반환한 값이다. return 키워드를 사용하지 않으면 프로미스 객체의 데이터는 undefined가 된다.\nreturn 키워드를 깜빡한 코드\nPromise.resolve(10) .then((data) =\u0026gt; { console.log(data) Promise.resolve(20) // 2번 }) .then((data) =\u0026gt; { console.log(data) // 1번 }) 1번은 의도와는 다르게 undefined가 출력 된다. 2번 코드에서 return 키워드를 입력하면 의도한 대로 20이 출력 된다.\n프로미스는 불변 객체라는 사실 명심하기프로미스는 불변 객체이다.\n프로미스가 수정된다고 생각하고 작성한 코드\nfunction requestData() { const p = Promise.resolve(10) p.then(() =\u0026gt; { // 1번 return 20 }) return p } requestData().then((v) =\u0026gt; { console.log(v) // 10 // 2번 }) 1번 then 메서드는 기존 객체를 수정하지 않고, 새로운 프로미스를 반환한다. 2번, 코드에서 20이 출력되길 원한다면 requestData 함수를 다음과 같이 수정해야 한다.\nthen 메서드로 생성된 프로미스를 반환하는 코드. function requestData() { return Promise.resolve(10).then((v) =\u0026gt; { return 20 }) } 프로미스를 중첩해서 사용하지 않기프로미스를 중첩해서 사용하면 콜백 헬과같이 프로미스 헬이 발생한다.\nrequestData1().then(result1 =\u0026gt; { requestData2(result2 =\u0026gt; { .... }); }); 가독성이 좋지 않기 때문에, 아래 24번과 같이 바꾸자.\n중첩된 코드를 리팩터링 한 코드 requestData1() .then(result1 =\u0026gt; { return requestData2(result1) }) .then(result2 =\u0026gt; { return ... // 1번 }) 만약 1번, 에서 result1 변수를 참조 해야 한다면 어떻게 해야 할까?\nPromise.all 함수를 사용하면 프로미스를 중첩하지 않고도 해결할수 있다.\nPromise.all을 사용해서 변수 참조 문제를 해결한 코드\nrequestData1() .then(result1 =\u0026gt; { return Promise.all([result1, requestData2(result1)]) // 1번 .then(([result1, result2]) =\u0026gt; { ........... }); 1번, Promise.all 함수로 입력하는 배열에 프로미스가 아닌 값을 넣으면, 그 값을 그대로 이행됨 상태인 프로미스처럼 처리된다.\n동기 코드의 예외 처리 신경 쓰기\n프로미스를 동기(sync)코드와 같이 사용할 때는 예외 처리에 신경 써야 한다.\n동기 코드에서 발생한 예외가 처리되지 않는 코드. function requestData() { doSync() // 1번 return fetch() .then((data) =\u0026gt; console.log(data)) .catch((error) =\u0026gt; console.log(error)) } 1번, doSync 함수가 반드시 fetch 전에 호출되어야 하는게 아니라면 다음과 같이 then 메서드 안에 넣어주는게 좋다.\n동기 코드도 예외처리가 되는 코드 function requestData() { return fetch() .then((data) =\u0026gt; { doSync() console.log(data) }) .catch((error) =\u0026gt; console.log(Error)) } doSync에서 발생하는 예외는 catch 메서드에서 처리가 된다.\n향상된 비동기 프로그래밍 async, await\nasync await 이해하기\n프로미스는 객체로 존재하지만, async await는 함수에 적용되는 개념이다.\n프로미스를 반환하는 async await 함수\nasync function getData() { return 123 //Promise {\u0026lt;fulfilled\u0026gt;: 123} } getData().then((data) =\u0026gt; console.log(data)) // 123 Promise {\u0026lt;fulfilled\u0026gt;: undefined} 프로미스를 반환하는 async await 함수 async function getData() { return Promise.resolve(123) } getData().then((data) =\u0026gt; console.log(data)) 프로미스의 then 메서드와 마찬가지로 async await 함수 내부에서 반환하는 값이 프로미스라면 그 객체를 그대로 반환한다.\nasync await 함수에서 예외가 발생하는 경우. async function getData() { throw new Error(\u0026#39;123\u0026#39;) } getData().catch((error) =\u0026gt; console.log(error)) // Error : 123 await 키워드를 사용하는 방법 function requestData(value) { return new Promise((resolve) =\u0026gt; setTimeout(() =\u0026gt; { console.log(\u0026#39;requestData:\u0026#39;, value) resolve(value) }, 100) ) } async function getData() { const data1 = await requestData(10) //1번 const data2 = await requestData(20) //1번 console.log(data1, data2) // 2번 return [data1, data2] } getData() // requestData: 10 // 3번 // requestData: 20 // 3번 // 10, 20 // 3번 1번, requestData 함수가 반환하는 프로미스가 처리됨 상태가 될 때 까지 2번,의 코드는 실행되지 않는다. 따라서 getData 함수를 호출 한 결과는 3번,이다.\nasync 키워드는 오직 async await 함수 내에서만 사용할 수 있다. 일반함수에서 사용하면 에러가 발생한다.\nawait 키워드는 async 키워드 없이 사용 할 수 없다. function getData(){ const data = await requestData(10); // 에러 발생 console.log(data); } async await는 프로미스보다 가독성이 좋다.\nasync await와 프로미스 비교하기 function getDataPromise() { asyncFunc1() .then((data) =\u0026gt; { console.log(data) return asyncFunc2() }) .then((data) =\u0026gt; { console.log(data) }) } // 1번 프로미스로 작성한 코드 async function getDataAsync() { const data1 = await asyncFunc1() console.log(data1) const data2 = await asyncFunc2() console.log(data2) } // 2번 async await로 작성한 코드 가독성이 async await로 작성 한 코드가 좋다. 간결한 이유는 async await 함수는 then 메서드를 호출할 필요가 없기 때문이다.\n의존성이 높은 코드에서 가독성 비교하기 function getDataPromise() { return asyncFunc1() .then(data1 =\u0026gt; Promise.all([data1, asyncFunc2(data1)])) // 1번 .then([data1, data2]) =\u0026gt; { return asyncFunc3(data1,data2); }); } async function getDataAsync() { // 2번 const1 data1 = await asyncFunc1(); const2 data2 = await asyncFunc2(data1); return asyncFunc3(data1, data2); } 1번, 두 반환값을 asyncFunc3 함수에 전달하기 위해 Promise.all을 사용했다. 2번, async await함수는 복잡한 의존성이 존재함에도 코드가 직관적이다.\nasync await 활용하기\n비동기 함수를 병렬로 실행하기. 순차적으로 실행되는 비동기 코드 async function getData() { const data1 = await asyncFunc1() const data2 = await asyncFunc2() // ... } 두 함수사이에 의존성이 없다면, 동시에 실행하는게 더 좋다. 프로미스는 생성과 동시에 비동기 코드가 실행된다. 따라서, 두 개의 프로미스를 먼저 생성하고 await 키워드를 나중에 사용하면 병렬로 실행되는 코드가 된다.\nawait 키워드를 나중에 사용해서 병렬로 실행되는 비동기 코드 async function getData() { const p1 = asyncFunc1() const p2 = asyncFunc2() const data1 = await p1 const data2 = await p2 } Promise.all을 사용해서 병렬로 처리하기 async function getData() { const [data1, data2] = await Promise.all([asyncFunc1(), asyncFunc2()]) // .... } 예외 처리하기 async await 함수 내부에서 발생하는 예외는 try catch 문으로 처리하는게 좋다. 동기와 비동기 함수 모두 catch 문에서 처리된다. async function getData() { try { await doAsync() return doSync() } catch (error) { console.log(error) } } 비동기함수와 동기함수에서 발생하는 모든 예외가 catch문에서 처리된다.\nThenable을 지원하는 async await Thenable은 프로미스 처럼 동작하는 객체다.\nasync await 함수에서 Thenable을 사용한 예\nclass ThenableExample { then(resolve, reject) { // 1번 setTimeout(() =\u0026gt; resolve(123), 1000) } } async function asyncFunc() { const result = await new ThenableExaple() // 2번 console.log(result) // 123 } 1번 ThenableExample 클래스는 then 메서드를 가지고 있으므로, ThenableExample 클래스로 생성된 객체는 Thenable이다. 2번 async await 함수는 Thenable도 프로미스 처럼 처리한다.\nsync/await , promise 차이 promise : 코드 실행 중에 만나더라도 무시하고 다음 코드를 실행한다. async-await : await을 만났을 때 ,해당 코드가 끝날때까지(요청이 마무리 될 떄까지, pending이 아닐떄까지) 기다렸다 코드를 실행한다. ","permalink":"https://findmytrueself.github.io/ko/frontend/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%97%90%EC%84%9C%EC%9D%98-%EB%B9%84%EB%8F%99%EA%B8%B0%EC%B2%98%EB%A6%AC/","tags":["Javascript"],"title":"자바스크립트에서의 비동기처리"},{"categories":null,"content":"웹브라우저의 구성 요소\nCall Stack : 자바스크립트에서 수행해야 할 함수들을 순차적으로 스택에 담아 처리 Web API : 웹 브라우저에서 제공하는 API로 AJAX나 TimeOut등의 비동기 작업 수행 Task Queue : Callback Queue 라고도 하며, Web API에서 넘겨받은 Callback함수를 저장. Event Loop : Call Stack이 비워져있다면, Task Queue의 작업을 Call Stack으로 옮김. setTimeout(() =\u0026gt; console.log(\u0026#34;Async Hi hun\u0026#34;)); console.log(\u0026#34;Hello! World\u0026#34;); // Hello! World // Async Hi hun 비동기 코드는 먼저 실행됨에도 불구하고, 나중에 출력되는걸 볼 수 있다.\nsetTimeOut 함수가 실행되고, Call Stack에 setTimeOut 함수가 추가 된다. setTimeOut 함수는 자바스크립트 엔진이 처리하지 않고, Web API가 처리한다. (NodeJS의 경우, Timers 모듈) Web API가 TimeOut 작업요청 시간이�지나면, Task Queue로 인자로 받은 callback 함수를 전달한다. 이후, 두번째 라인의 console.log가 Call Stack에 추가된다. 그리고 Call Stack의 console.log가 곧바로 실행되고, 콘솔에는 \u0026ldquo;Hello! World\u0026rdquo; 문자열이 출력된다. 이때, 자바스크립트의 Event Loop는 Call Stack이 비워져있는지 항상 확인하는데, 방금 전, console.log가 실행되며, Call Stack이 비워진 것을 확인한다. Call Stack이 비워진 것을 확인한 Event Loop는 Task Queue에 있던 callback함수를 Call Stack으로 옮겨 작업을 수행한다. 이후 console.log의 문자열 \u0026ldquo;Async Hi Hun\u0026rdquo; 출력 모든 작업이 끝나면, Call Stack과 Task Queue가 비워진 것을 볼 수 있다.\n","permalink":"https://findmytrueself.github.io/ko/frontend/%EC%9B%B9%EC%84%9C%EB%B9%84%EC%8A%A4%EA%B0%80-%EB%8F%99%EC%9E%91%ED%95%98%EA%B2%8C-%ED%95%98%EB%8A%94-%EA%B8%B0%EB%B3%B8-%ED%94%8C%EB%A1%9C%EC%9A%B0/","tags":["Javascript","Web"],"title":"웹서비스가 동작하게 하는 기본 플로우"},{"categories":null,"content":"","permalink":"https://findmytrueself.github.io/manifest.json","tags":null,"title":""},{"categories":null,"content":"","permalink":"https://findmytrueself.github.io/ko/search/_index.de/","tags":null,"title":""},{"categories":null,"content":"","permalink":"https://findmytrueself.github.io/ko/search/_index.es/","tags":null,"title":""},{"categories":null,"content":"","permalink":"https://findmytrueself.github.io/ko/search/_index.fr/","tags":null,"title":""},{"categories":null,"content":"","permalink":"https://findmytrueself.github.io/ko/search/_index.hi/","tags":null,"title":""},{"categories":null,"content":"","permalink":"https://findmytrueself.github.io/ko/search/_index.jp/","tags":null,"title":""},{"categories":null,"content":"","permalink":"https://findmytrueself.github.io/ko/search/_index.nl/","tags":null,"title":""},{"categories":null,"content":"","permalink":"https://findmytrueself.github.io/ko/search/_index.pl/","tags":null,"title":""},{"categories":null,"content":"","permalink":"https://findmytrueself.github.io/ko/search/_index.ru/","tags":null,"title":""},{"categories":null,"content":"","permalink":"https://findmytrueself.github.io/ko/search/_index.zh-cn/","tags":null,"title":""},{"categories":null,"content":"What is a Normal Transaction? A typical transaction on the Ethereum blockchain refers to the simple transfer of Ether (ETH) or tokens between two wallet addresses.\nThese transactions are initiated by users and are directly recorded on the blockchain, making them easy to track.\nCharacteristics User-Initiated: A normal transaction is typically initiated by an individual or entity sending ETH or tokens from one address to another.\nRecorded on the Blockchain: All normal transactions are permanently recorded on the Ethereum blockchain, providing a transparent and immutable record.\nTransaction Fees: Users must pay gas fees to miners to process and confirm the transaction. The fees vary depending on network congestion and transaction complexity.\nSimple Structure: A normal transaction includes basic information like the sender\u0026rsquo;s and receiver\u0026rsquo;s addresses, the amount transferred, and the gas limit.\nVisibility: These transactions can be viewed by anyone on Etherscan, allowing users to track transfers and check balances.\nHow Do Normal Transactions Work? Transaction Creation: The user specifies the recipient\u0026rsquo;s address and the amount of ETH or tokens to send in a wallet app.\nTransaction Signing: The transaction is signed with the sender\u0026rsquo;s private key to verify authenticity.\nTransaction Broadcasting: The signed transaction is sent to the Ethereum network for validation.\nTransaction Pool: The transaction enters the mempool, where miners select transactions to include in the next block.\nMining and Confirmation: Miners solve a cryptographic puzzle and add the block containing the transaction to the blockchain.\nFinality: Once confirmed, the transaction is recorded on the blockchain, and the recipient\u0026rsquo;s balance is updated.\nGas Fees: The sender pays gas fees based on the complexity of the transaction and network congestion.\nUse Cases for Normal Transactions P2P Transfers: Sending ETH or tokens between individuals.\nPayments for Goods and Services: Making purchases using cryptocurrency.\nFunding Wallets: Transferring assets to another wallet for trading or investment purposes.\nHow to View a Normal Transaction? Visit Etherscan: Go to etherscan.io.\nSearch for the address: Enter the wallet address in the search bar.\nAccess the address page: Click the address from the search results.\nNavigate to the \u0026ldquo;Transactions\u0026rdquo; tab: Click the \u0026ldquo;Transactions\u0026rdquo; tab to see a list of all normal transactions.\nReview details: Each transaction shows the transaction hash, sender and receiver addresses, value, gas fees, and timestamp.\nWhat is an Internal Transaction? Internal transactions, also known as \u0026ldquo;message calls\u0026rdquo; or \u0026ldquo;contract interactions,\u0026rdquo; occur within smart contracts on the Ethereum blockchain.\nUnlike regular transactions that involve direct transfers of Ether or tokens between wallet addresses, internal transactions result from executing code within smart contracts.\nCharacteristics Triggered by smart contracts: Internal transactions are created when a smart contract calls another smart contract or sends Ether during its execution.\nNot directly recorded on the blockchain: While internal transactions can be traced back to the point where the original regular transaction was initiated, they don\u0026rsquo;t have their own transaction hash and are not explicitly recorded on the blockchain like regular transactions.\nComplex logic: Internal transactions often involve complex logic, such as token transfers, multi-signature operations, or automated functions triggered by contract conditions.\nVisibility on Etherscan: Although not shown in the main transaction list, internal transactions can be viewed in the \u0026ldquo;Internal Transactions\u0026rdquo; tab of a specific contract or wallet on Etherscan.\nUse Cases: Internal transactions are typically used in decentralized applications (dApps) and decentralized finance (DeFi) protocols to execute complex contract interactions.\nHow Do Internal Transactions Work? Event Trigger: Internal transactions are initiated when a smart contract is executed, usually in response to a regular transaction.\nContract Interaction: During execution, the smart contract may call another contract or send Ether as part of its logic.\nNo Separate Transaction Hash: Internal transactions don’t have unique transaction hashes and are tied to the original regular transaction.\nExecution Logic: Internal transfers happen as part of the smart contract code, which may involve complex tasks such as token transfers or multi-signature approvals.\nVisibility: While not visible in the main transaction list, internal transactions can be found in the \u0026ldquo;Internal Transactions\u0026rdquo; tab on Etherscan for the associated contract or wallet.\nUse Cases for Internal Transactions Decentralized Finance (DeFi): Automating lending, borrowing, and liquidity provisioning within protocols.\nToken Swaps: Managing asset transfers between liquidity pools on decentralized exchanges (DEXs).\nAutomated Market Makers (AMMs): Adjusting token prices based on supply and demand through internal movements.\nCrowdfunding and ICOs: Handling fund allocation and token distribution transparently during fundraising events.\nGaming and NFTs: Enabling the seamless transfer of in-game assets and NFTs between players.\nHow to View Internal Transactions? Visit Etherscan: Go to etherscan.io.\nSearch for an Address or Transaction: Enter a wallet address or transaction hash in the search bar.\nAccess the Address or Transaction Page: Click the relevant result to open the dedicated page.\nGo to the \u0026ldquo;Internal Transactions\u0026rdquo; Tab: Find the “Internal Transactions” tab on the address or transaction page.\nReview Details: View the list of internal transactions, including the sender, receiver, value, and the associated regular transaction.\nNormal Transactions vs. Internal Transactions The following table highlights the differences between regular and internal transactions on Etherscan.\nCategory Normal Transactions Internal Transactions Definition Direct transfers of ETH or tokens between wallets. Transfers occurring within a smart contract’s execution. Initiation Triggered by user actions (e.g., sending ETH). Triggered by smart contract execution or interaction. Visibility Easily visible on the blockchain and Etherscan. Not recorded as a separate entry; visible in a special tab. Transaction Hash Each transaction has a unique hash. No unique transaction hash, linked to the initial transaction. Gas Fee The sender must pay a gas fee. Usually included in the initial transaction’s gas fee. Use Cases Peer-to-peer transfers, payments, and token transfers. DeFi operations, token swaps, game transactions, contract interactions. Complexity Generally simple. Can involve complex logic and automated processes. Recording Directly recorded on the Ethereum blockchain. Recorded in the context of smart contract execution. Reference\nhttps://www.geeksforgeeks.org/normal-transactions-vs-internal-transactions-in-etherscan/ ","permalink":"https://findmytrueself.github.io/en/blockchain/internaltx/","tags":["Blockchain","Ethereum"],"title":"Normal Transactions and Internal Transactions"},{"categories":null,"content":"Divisors: An integer that can divide another integer without a remainder.\nFinding divisors by dividing all numbers Condition: Add the number if the remainder is 0 when divided.\nSkip if the condition is not met.\nRange of condition: The divisor can be at most the number itself, so set the loop to iterate up to the number.\nlet num = 8; // 약수를 찾기 위한 정수 설정 let result = [] let index = 1; while (index \u0026lt;= num) { if (num % index === 0) result.push(index) index++ } console.log(result) // [ 1, 2, 4, 8 ] Checking only up to half of the given number Divisors, except for the number itself, cannot be larger than num / 2, so check only up to half.\nlet num = 8; let result = [] let index = 1; while (index \u0026lt;= num / 2) { if (num % index === 0) result.push(index) index++ } result = [...result, num] // 본인 값 추가까지 추가 console.log(result) // [ 1, 2, 4, 8 ] Using the square root (Math.sqrt) Find the divisors of num within the range of 1 to the square root of num.\nIf num is 100, divide by numbers from 1 to 10 and find those that result in a remainder of 0.\n[1, 2, 4, 5, 10]\nAlso, the result of dividing num by these divisors will be divisors of num.\n100 / 1 = 100\n100 / 2 = 50\n100 / 4 = 25\n100 / 5 = 20\n100 / 10 = 10 → duplicate\n[1, 2, 4, 5, 10, 10, 20, 25, 50, 100]\nRemove duplicates\nExclude the divisor from the result if it equals num / divisor.\n[1, 2, 4, 5, 10, 20, 25, 50, 100]\nUsing Set\nlet num = 100; let result = [] let index = 1; while (index \u0026lt;= Math.sqrt(num)) { if (num % index === 0) { result.push(index) if (num / index !== index) result.push(num / index) } index++ } result.sort((a, b) =\u0026gt; a - b) console.log(result) // [ 1, 2, 4, 5, 10, 20, 25, 50, 100 ] Reference\nhttps://velog.io/@woody_/JS-%EC%95%BD%EC%88%98-%EA%B5%AC%ED%95%98%EA%B8%B0-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98 ","permalink":"https://findmytrueself.github.io/en/algorithm/%EC%95%BD%EC%88%98%EA%B5%AC%ED%95%98%EA%B8%B0/","tags":["Algorithm","Javascript"],"title":"Finding Divisors"},{"categories":null,"content":"3rd Year Web3 Frontend Developer - Hun Im Experience Web3 Frontend Developer Aergo | 2023.01 – present\nResponsible for developing and maintaining frontend open-source functionalities for Aergo Blockchain.\nDeveloped the Aergo Connect 3.0 Chrome extension personal wallet. ( 📎 배포 | 깃헙 )\nMigrated from Manifest2 to Manifest3\nAdded Multi Accounts management and Private Network functionality\nIntegrated Hardware Wallet Nano Ledger support\n#Typescript #Vuejs #Vuex #Chrome Extension #Manifest3 #IndexedDb #ServiceWorker\nImproved UI and developed contracts interactive (Read \u0026amp; Write) features for Aergo Scan. ( 📎 배포 | 깃헙 )\nImplemented a feature that allows users to directly execute transactions and query contract data through smart contracts in the scanner.\nAdded Internal Tx viewing feature and original source code viewing feature.\n#Typescript #Vuejs #Vuex\nDeveloped the Aergo Bridge service for Aergo and Ethereum bridge and admin. ( 📎 배포 )\n- Successfully bridged over 5 million Aergo to Ethereum within 4 months of launch (as of September 13, 2024)\n#Next.js(v14) #react-hook-form #react-query #wagmi\nMigrated Aergo SDK (Hera.js) from GRPC to GRPC JS. ( 📎 깃헙 )\n- Updated the SDK to be compatible with the latest version of Node.js\nFrontend Developer Blocko | 2022.01 – present\nResponsible for Web3 services and UI development, including backend API integration\nGEMVERSE - Added Aptos wallet integration and personal signature feature.\nImplemented a feature that securely sends signatures to the backend by serializing them during the signing process. Improved features and fixed bugs for the enterprise private blockchain (Aergo Enterprise Manager)\nFixed bugs in the chain and node editing functionality and synchronized the data to the latest state Projects • Road To Interview (21년 11월~4주)\nA web app designed for developers to practice technical interviews on their own. ( 📎 깃헙 | 기획서 )\n[Frontend] Javascript, React, Emotion, Redux\n[Client Deployment] AWS(S3, Route53, Certificate Manager, CodePipeline, CloudFront)\nCreated a video interview page using the WebRTC API Developed a job listing page for developers using server-crawled data Set up client auto-deployment and PWA deployment Education CodeStates\nSoftware Engineering Bootcamp IM 29 Completion\n2021.04 – 2021.11\nCommunication University of China\nBachelor\u0026rsquo;s Degree in Communication\n2015 – 2019\nSkills • Javascript\n• Typescript\n• React.js\n• Next.js\n• Web 3 (Blockchain)\n• Vue.js\nLanguages • Korean - Native\n• English - C1(ESL)\n• Chinese - HSK6\nContributions I contribute to Aergo open-source projects as a member of the Aergo team. As a 3rd-year frontend developer, I develop within the React ecosystem. ","permalink":"https://findmytrueself.github.io/en/posts/about-me/","tags":null,"title":"ABOUT ME"},{"categories":null,"content":"function solution(s) { const obj = {\u0026#39;zero\u0026#39;:0, \u0026#39;one\u0026#39;:1, \u0026#39;two\u0026#39;:2, \u0026#39;three\u0026#39;:3, \u0026#39;four\u0026#39;:4, \u0026#39;five\u0026#39;:5, \u0026#39;six\u0026#39;:6, \u0026#39;seven\u0026#39;:7, \u0026#39;eight\u0026#39;:8, \u0026#39;nine\u0026#39;:9} let stringNum = \u0026#39;\u0026#39; let answer = \u0026#39;\u0026#39; for(let i=0; i\u0026lt;s.length; i++){ let temp = +s[i] if(isNaN(temp)){ stringNum += s[i] if(obj[stringNum] || obj[stringNum] === 0){ // A counterexample is \u0026#39;one0zero0\u0026#39;. Since 0 is a falsy value, you need to explicitly handle the value to ensure accuracy. answer += obj[stringNum] stringNum = \u0026#39;\u0026#39; } } else { answer += s[i] } } return +answer } ","permalink":"https://findmytrueself.github.io/en/algorithm/%EC%88%AB%EC%9E%90-%EB%AC%B8%EC%9E%90%EC%97%B4%EA%B3%BC-%EC%98%81%EB%8B%A8%EC%96%B4lv1/","tags":["Algorithm","Javascript"],"title":"Number Strings and Words (Level 1)"},{"categories":null,"content":"function getCombinations(arr, selectNumber) { const results = []; if (selectNumber === 1) { return arr.map((value) =\u0026gt; [value]); // Return each element as an array } arr.forEach((fixed, index, array) =\u0026gt; { const rest = array.slice(index + 1); // The array after the current element const combinations = getCombinations(rest, selectNumber - 1); // Recursive call const attached = combinations.map((combination) =\u0026gt; [fixed, ...combination]); // Attach the current element to the combinations results.push(...attached); }); return results; } ","permalink":"https://findmytrueself.github.io/en/algorithm/%EC%A1%B0%ED%95%A9combinations/","tags":["Algorithm","Javascript"],"title":"Combinations"},{"categories":null,"content":"This exact problem appeared in a live coding test for the company I want to join.\nI had solved this problem three years ago while preparing for coding tests as a new graduate, but I couldn\u0026rsquo;t remember it since it\u0026rsquo;s been a while.\nIt was so frustrating that I couldn\u0026rsquo;t solve it halfway through, so I decided to review it.\nfunction solution(s) { let stack = []; let obj = { \u0026#39;(\u0026#39;: \u0026#39;)\u0026#39;, \u0026#39;{\u0026#39;:\u0026#39;}\u0026#39;, \u0026#39;[\u0026#39;:\u0026#39;]\u0026#39; }; for (let i = 0; i \u0026lt; s.length; i++) { if (Object.keys(obj).includes(s[i])) { stack.push(s[i]); // Only push the left parentheses onto the stack. } else { let last = stack.pop(); // Pop the last item from the stack. if (s[i] !== obj[last]) { // If it doesn\u0026#39;t match the correct closing bracket, return false. return false; } } } if (stack.length !== 0) { // If there\u0026#39;s anything left in the stack, it means not all parentheses were closed, so return false. return false; } else { return true; // If the stack is empty, all parentheses were correctly matched, so return true. } } ","permalink":"https://findmytrueself.github.io/en/algorithm/%EC%98%AC%EB%B0%94%EB%A5%B8%EA%B4%84%ED%98%B8/","tags":["Javascript","Algorithm"],"title":"Valid Parentheses (Level 2)"},{"categories":null,"content":"Let\u0026rsquo;s take a look at Hyperledger Besu, one of the representative private blockchains based on Ethereum, used in enterprise environments.\nFirst, there\u0026rsquo;s a question: Blockchain\u0026rsquo;s fundamental concept is aimed at decentralization with a focus on public transparency, so doesn’t the concept of a \u0026ldquo;private\u0026rdquo; blockchain contradict that?\nThe basic concept of a private blockchain is its use in corporate or personal environments.\nIn short, it means creating another Ethereum world tailored to the needs of the builder.\nImmutability and transparency are still necessary in any environment. Therefore, instead of using a traditional database, private blockchains with these advantages are used in specific settings.\nHyperledger Besu Besu is an open-source platform that supports EVM. It can be used to create a private blockchain and also connect with Ethereum to form a public network.\nThe image below compares different consensus algorithms. Besu Private Network Structure It forms an independent network that is not connected to the public Ethereum network, maintaining transaction privacy and processing transactions. Commonly used consensus algorithms include QBFT, IBFT 2.0, and Clique. Consensus Algorithm Comparison\nQBFT (Quorum Byzantine Fault Tolerance): Developed by ConsenSys in collaboration with J.P. Morgan, QBFT is an extension of the IBFT consensus algorithm, offering enhanced features for enterprise use cases.\nIBFT (Istanbul Byzantine Fault Tolerance): IBFT solves some issues that arise when applying PBFT (Practical Byzantine Fault Tolerance) to blockchains, ensuring transaction finality.\nClique PoA: The default Proof of Authority (PoA) consensus algorithm included in go-ethereum.\nRaft-based Consensus: A consensus algorithm designed for fast block times, transaction finality, and block creation on demand.\nPermission Controls\nNode Permission Control: Determines whether each node can participate in the network.\nAccount Permission Control: Determines whether each account can create transactions or contracts.\nBesu Public Network Structure It can be connected to the public Ethereum network and acts as an execution client for Ethereum. After the Ethereum Merge migration, it is divided into a consensus client and an execution client, with Besu serving as the execution client. The Teku consensus client is commonly used in conjunction with Besu. Reference\nhttps://usa.visa.com/solutions/crypto/enterprise-blockchain.html https://blog.web3labs.com/a-comparison-of-ethereum-clients https://blog.web3labs.com/web3development/comparing-byzantine-fault-tolerance-consensus-algorithms https://www.hyperledger.org/blog/why-hyperledger-besu-is-a-top-choice-for-financial-use-cases Use cases of Hyperledger Besu and Quorum\nLACChain RTI Blockchain Poste Italiane Onyx Digital Assets Synaptic Health Alliance ","permalink":"https://findmytrueself.github.io/en/blockchain/besu/","tags":["Blockchain","Ethereum"],"title":"Ethereum Private Blockchain with Besu"},{"categories":null,"content":"Types of Major Consensus Algorithms Proof of Work (PoW) Description: A method where network participants compete to solve very complex mathematical problems to create blocks. The node that solves the problem first earns the right to add a new block. Examples: Bitcoin, Ethereum (pre-2.0). Pros: High security and operates in a decentralized network without centralized authority. Cons: Extremely high energy consumption and slow transaction speeds. Proof of Stake (PoS) Description: A method where nodes obtain the right to create blocks based on the amount of cryptocurrency they hold (stake). The more stake, the higher the chance to add a new block. Examples: Ethereum (2.0), Cardano, Polkadot. Pros: Energy efficient and faster block generation compared to PoW. Cons: Potential centralization by nodes with large stakes. Delegated Proof of Stake (DPoS) Description: Users elect a set number of delegates who are responsible for creating blocks. These representatives are chosen by network participants through voting, and they perform block verification and generation tasks. Examples: EOS, Tron, Steem. Pros: Faster transaction speeds than PoS and energy efficiency. Cons: Risk of centralization due to reliance on a small number of elected nodes. Proof of Authority (PoA) Description: A small, trusted group of validators are responsible for creating blocks. These validators must be verified as trustworthy within the network and are responsible for adding blocks. Examples: VeChain, certain private blockchains. Pros: Very fast and operates efficiently in a trusted environment. Cons: High likelihood of centralization and reliance on a small group of validators. Delayed Proof of Work (dPoW) Description: Provides an additional security layer by using the hash power of an existing PoW blockchain to secure a secondary chain. The secondary chain leverages the security of the primary PoW chain. Example: Komodo. Pros: Utilizes the security of existing PoW blockchains while increasing efficiency. Cons: Dependency on an existing PoW chain. Byzantine Fault Tolerance (BFT) Description: A method to address the Byzantine Generals Problem, allowing the system to continue functioning correctly even if some nodes act maliciously or fail to respond. Examples: Hyperledger, Tendermint. Pros: Provides high security and ensures reliable outcomes even with untrustworthy nodes. Cons: More complex than PoW or PoS and may slow down as the network grows. Practical Byzantine Fault Tolerance (PBFT) Example: Hyperledger Fabric. Features: Requires more than half of the network nodes to reach the same state for consensus. QBFT (Quorum-based Byzantine Fault Tolerance) Description: QBFT is a consensus algorithm in the BFT family that requires the approval of more than half of the nodes in the network to reach consensus. Developed to maintain both security and efficiency while tolerating Byzantine faults, it is an evolution of the PBFT algorithm. Example: Used in Hyperledger Besu, it is known to be well-suited for enterprise blockchains. Pros: Even if malicious nodes are present, the network can securely reach consensus as long as there is a majority of trustworthy nodes. It also does not consume as much energy as PoW and can process transactions quickly. Cons: As the network size grows, communication costs for consensus increase, which may degrade performance. The larger the number of nodes, the slower the network becomes. QBFT is primarily used in enterprise blockchain environments, where it balances Byzantine fault tolerance with performance and scalability.\nHybrid Consensus Algorithm Example: Decred. Features: Combines two or more consensus algorithms to maximize stability and efficiency. Raft Algorithm Description: Raft operates as a leader-based consensus algorithm in distributed systems to maintain consistency across multiple nodes. The leader handles client requests and replicates logs to follower nodes to maintain consistency. If the leader fails, a new leader is elected through voting. Examples: Etcd, Consul. Pros: Simple structure, easy to understand and implement, and fast, stable leader election and log replication. Cons: Since the structure relies on the leader, frequent leader changes may degrade performance, and recovery time is needed if the leader fails. Tendermint: Example: Cosmos. Features: A BFT-based algorithm that achieves fast and stable consensus. Often combined with PoS for use. Other Consensus Algorithms Federated Byzantine Agreement (FBA): Used by Ripple and Stellar. Leased Proof of Stake (LPoS): Used by Waves. Proof of Burn (PoB): A method where a certain amount of cryptocurrency is burned to gain the right to create blocks. ","permalink":"https://findmytrueself.github.io/en/blockchain/%ED%95%A9%EC%9D%98-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/","tags":["Blockchain"],"title":"Consensus Algorithms"},{"categories":null,"content":"What is Ethereum? A blockchain-based platform used to run smart contracts and decentralized applications (dApps).\nIt offers various features beyond cryptocurrency transactions, including smart contract functionality.\nThe Ethereum network consists of numerous nodes, each responsible for maintaining and validating the Ethereum blockchain.\nEthereum Virtual Machine (EVM)\nA virtualized computing environment that runs smart contracts within the Ethereum network.\nThe core component of smart contracts and decentralized applications.\nActs as a virtual computer that operates in a decentralized manner on the Ethereum network.\nSmart contracts are written in the Solidity language, compiled into bytecode, and executed by the EVM.\nERC\nERC (Ethereum Request for Comments) is a process used to propose and define standards for smart contracts on the Ethereum blockchain.\nERC-20: Description: The most widely used token standard, used to create fungible tokens on the Ethereum blockchain. ERC-20 tokens have the same value and properties, with each unit treated equally. Use Cases: Tokens used in ICOs (Initial Coin Offerings), utility tokens for various projects. Functions: Defines basic token transfer and approval functions such as transfer, approve, and transferFrom. ERC-721: Description: The standard for non-fungible tokens (NFTs), where each token has unique properties and cannot be exchanged one-to-one with other tokens. Use Cases: Represents ownership of digital assets (e.g., CryptoKitties), art, and in-game items. Functions: Tracks and transfers ownership of specific tokens using functions like ownerOf and transferFrom. ERC-1155: Description: A multi-token standard that allows for the management of both fungible and non-fungible tokens within a single contract. Use Cases: Useful in games where various types of items (both regular and unique) need to be managed. Functions: Efficiently transfers and manages multiple types of tokens using functions like safeTransferFrom and balanceOf. ERC-777: Description: An improved token standard over ERC-20, offering a more flexible transfer mechanism and enhanced security features. It allows the use of custom hooks during token transfers. Use Cases: Used to overcome limitations of ERC-20 and in more complex smart contract systems. ERC-1400: Description: A standard for security tokens, providing stricter control over token ownership to meet legal requirements. Use Cases: Security tokens (STOs), financial assets where regulatory compliance is essential. ","permalink":"https://findmytrueself.github.io/en/blockchain/ethereum/","tags":["Blockchain","Ethereum"],"title":"Ethereum"},{"categories":null,"content":"Closures are a fundamental concept in JavaScript.\nIt\u0026rsquo;s a concept that is often asked about in technical interviews, and I remember memorizing it while preparing for my own technical interviews.\nHowever, I didn\u0026rsquo;t quite understand how closures are used in practice, and I often pondered how to apply them effectively. This time, I want to study the concept of closures in more depth.\nProblem\nWhen passing a function as a parameter to customHook, let’s observe how the state value inside the function is output when the useCustom component is unmounted.\nimport useCustom from \u0026#39;./hooks/useCustom\u0026#39; import { useState } from \u0026#39;react\u0026#39; export default function Home() { const [state, setState] = useState(0) useCustom(() =\u0026gt; console.log(\u0026#39;inner func state:\u0026#39;, state)) return ( \u0026lt;div className=\u0026#34;grid grid-rows-[20px_1fr_20px] items-center justify-items-center min-h-screen p-8 pb-20 gap-16 sm:p-20 font-[family-name:var(--font-geist-sans)]\u0026#34;\u0026gt; \u0026lt;div\u0026gt;{state}\u0026lt;/div\u0026gt; \u0026lt;button onClick={() =\u0026gt; setState(state + 1)}\u0026gt;+\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ) } import React, { useEffect } from \u0026#39;react\u0026#39; const useCustom = (func: Function, state: any) =\u0026gt; { console.log(\u0026#39;params state:\u0026#39;, state) useEffect(() =\u0026gt; { return () =\u0026gt; func() }, []) return \u0026lt;div\u0026gt;useCustom\u0026lt;/div\u0026gt; } export default useCustom Code Explanation\nOn the initial render, the state is set to 0. The console.log inside useCustom outputs the value of state, which is the initial value of 0. At this point, the func function passed to useCustom also retains the state of 0 due to closures. When the useCustom component is unmounted, this function executes, but the state remains at 0. Since the dependency array is empty, the useEffect runs only once, and it does not re-execute even if the state changes. If you want to use the latest state value, you need to add state to the dependency array of useEffect. Otherwise, due to closures, it will reference the previous state. ","permalink":"https://findmytrueself.github.io/en/frontend/%EB%A6%AC%EC%95%A1%ED%8A%B8%EC%97%90%EC%84%9C%EC%9D%98-%ED%81%B4%EB%A1%9C%EC%A0%80/","tags":["Javascript","React"],"title":"Closures in React"},{"categories":null,"content":"I am a third-year front-end developer at my current company.\nI believe I’ve done many important things here, but when it comes to confidently answering what I’ve accomplished, it feels awkward.\nRecently, while using the updated ChatGPT 4o, I’ve noticed that I’m increasingly relying on it.\nI always think that there is no such thing as 100% certainty in anything, but as the engine upgrades, it gets closer to providing correct answers.\nBefore using the paid version, I used to dismiss ChatGPT for giving silly responses, but now it’s truly different.\nIs it really the same as the way I used to solve problems by constantly googling? I’m not sure. Is it okay to find answers through googling, but not through ChatGPT? That seems strange.\nAnyway, I have many concerns about what kind of career I should pursue in the future.\nThe job market is getting tighter, and I’m personally feeling the difficulties of making a successful job transition.\nI think I need to keep challenging myself. I have to keep studying and live with the mindset that tomorrow should be better than today.\n","permalink":"https://findmytrueself.github.io/en/diary/%EB%AF%B8%EB%9E%98%EC%97%90-%EB%8C%80%ED%95%9C-%EA%B3%A0%EB%AF%BC/","tags":null,"title":"Concerns About the Future"},{"categories":null,"content":"Using Set\nThe main difference between using a regular array and a Set is how they handle duplicate elements.\nlet setArr = new Set([\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;d\u0026#39;,\u0026#39;a\u0026#39;]) console.log(setArr) // 출력: Set(4) { \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39; } A Set is a data structure that does not allow duplicates. This means that even if you try to add the same value multiple times to a Set, only one instance of that value will be kept. To convert a Set into an array, you can use Array.from(). let report = [\u0026#34;muzi frodo\u0026#34;, \u0026#34;apeach frodo\u0026#34;, \u0026#34;frodo neo\u0026#34;, \u0026#34;muzi neo\u0026#34;, \u0026#34;muzi frodo\u0026#34;]; let uniqueReports = new Set(report); console.log(uniqueReports); // 출력: Set(4) { \u0026#39;muzi frodo\u0026#39;, \u0026#39;apeach frodo\u0026#39;, \u0026#39;frodo neo\u0026#39;, \u0026#39;muzi neo\u0026#39; } Characteristics of Set\nAutomatically removes duplicates It is useful when you need to remove duplicate elements and order is not important. ","permalink":"https://findmytrueself.github.io/en/algorithm/set/","tags":["Algorithm","Javascript"],"title":"Array Using Set"},{"categories":null,"content":"ADHD is a term that I’ve been hearing a lot these days.\nADHD(Attention Deficit Hyperactivity Disorder)\nIt’s characterized by decreased attention, leading to distractibility and impulsiveness.\nIt is not considered a mental illness, but rather a developmental disorder.\nMy Childhood\nLooking back on my childhood, I remember reading 10 or 20 books in one sitting. My mom probably thought she had given birth to a genius.\nHowever, after entering elementary school, I stopped reading altogether and spent that time playing games.\nI still don’t know if I have ADHD, but even now, if it’s not something I like, I find it difficult to sit and read.\nI was able to see my elementary school report cards, and they noted that I was distracted in first and second grade. I thought the teacher wrote that because she didn’t like me.\nOne characteristic of ADHD is a lack of time awareness.\nEven now, I often arrive late. In high school, I was punished for being late, and on one occasion, I was late three times in a row, receiving 10 lashes on the first day, 20 on the second, and 30 on the third.\nDid I want to be late and get beaten? It was a long time ago, so I want to laugh about it now.\nI only needed to leave 30 minutes earlier than usual, but I could never manage that.\nI never feel the urge to leave quickly, and when I finally force myself to leave on time, I end up checking if I’ve forgotten something, miss my ride, and despite feeling busier than anyone else, I always end up late.\nNow that I think about it, even though I lived just a 3-minute walk from school in middle school, I was often late. It was slightly better, but the distance seemed irrelevant.\nMy Current Self\nI constantly feel pressure to wake up early and to meet my work hours.\nI liked this company because the flexible working hours allowed me to focus solely on my tasks.\nHowever, I feel like I’m drifting away from that atmosphere, and it’s mentally exhausting. I want to change jobs.\nThe ideal company for me would be one where everyone knows how to do their jobs well, but I feel like we’re moving further away from that ideal.\nVisiting a Psychiatrist\nMy depression has worsened, and I’ve been suffering from insomnia. Recently, I visited a psychiatrist for the first time.\nThe trigger was that despite sleeping only one or two hours for two nights, I still couldn’t fall asleep.\nTalking to someone who listened to my troubles made me feel a lot better.\nThe doctor suggested that I might have ADHD and recommended that I take an ADHD test next time.\nThe medication worked well. I was able to sleep soundly. After taking the medication, I could sleep deeply for eight hours. I still feel a bit dazed during the day, possibly due to the lingering effects of the medication.\nIt seems that I’ve also been less irritable.\nHowever, I’m worried that if I feel spaced out at night, I might start relying too much on that medication (Xanax), so I need to learn to manage it responsibly.\n","permalink":"https://findmytrueself.github.io/en/diary/adhd/","tags":null,"title":"Am I ADHD?"},{"categories":null,"content":"The biggest trial in my life has come.\nEarlier this year, I made a lot of money from investments, which led to excessive confidence.\nI kept making big bets, and ultimately, I faced significant losses.\nIt was a moment when I felt my mental state crumbling every day.\nI couldn’t focus on work at all, and I experienced panic disorder symptoms for a while.\nJust then, a project that needed to be completed urgently came up, and for a month, I focused on that work, spending all my time day and night.\nSince I couldn\u0026rsquo;t think of anything else, I managed to hold on mentally until it was finished.\nAfter the project ended, I fell back into burnout.\nAt work, zoning out became my routine.\nI watched a lot of videos on mental illness on YouTube.\nI learned about the concept of narcissism and realized there were quite a few narcissists around me, draining me without me even noticing.\nMy depression worsened. I can’t remember the last time I smiled genuinely.\nSince I haven’t completely lost myself yet, I’m trying to rise again.\nI hope this blog can serve as a stepping stone. I need to clean my house, start exercising again, and study more.\nI recently had a job interview and felt pathetic for not being able to answer simple questions.\nI’m feeling too anxious. It’s important to take things slowly and steadily. Even gaming no longer brings me joy; I feel like I can\u0026rsquo;t improve anymore.\nI should spend that time cultivating myself moving forward.\n","permalink":"https://findmytrueself.github.io/en/diary/2024/","tags":null,"title":"Trials of 2024"},{"categories":null,"content":"Permutation is a concept learned in high school mathematics.\nAt that time, I memorized the formulas without really understanding what permutations were or when to use them (I guess that’s why I didn’t study well as a kid\u0026hellip;)\nWhat is a Permutation?\nA permutation refers to arranging all the elements of a set while considering the order.\nIn other words, it refers to all possible arrangements of n given elements in all possible orders.\nCharacteristics of Permutations\nIn permutations, the order is important. For example, {1, 2, 3} and {3, 2, 1} are considered different permutations. The number of permutations that can be made with n elements is calculated as n! (n factorial). For example, with 3 elements, the number of permutations is 3! = 3 × 2 × 1 = 6. Applications of Permutations\nWhen you need to consider all possible orders (e.g., scheduling problems) When you need to list all possible cases to make the optimal choice (e.g., finding the shortest path) JS Function\nfunction getPermutations(arr) { let results = [] function permute(current, remaining) { if (remaining.length === 0) { results.push(current) } for (let i = 0; i \u0026lt; remaining.length; i++) { let next = current.concat(remaining[i]) let newRemaining = remaining.slice(0, i).concat(remaining.slice(i + 1)) permute(next, newRemaining) } } permute([], arr) return results } const array = [1, 2, 3] const permutations = getPermutations(array) console.log(permutations) /** [ [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1] ] */ ","permalink":"https://findmytrueself.github.io/en/algorithm/permutation/","tags":["Algorithm","Javascript"],"title":"Permutation"},{"categories":null,"content":"Array.at(idx) is a method introduced in ES2022.\nLet\u0026rsquo;s explore the differences between the traditional Array[idx] and Array.at(idx).\nDifferences\nThe most significant difference is the support for negative indices.\nconst arr = [10, 20, 30] console.log(arr[-1]) // undefined const arr = [10, 20, 30] console.log(arr.at(-1)) // 30 ","permalink":"https://findmytrueself.github.io/en/algorithm/arrayat/","tags":["Algorithm","Javascript"],"title":"Difference Between Array.at and Array[idx]"},{"categories":null,"content":"During a coding test, I wanted to create an array of N numbers and use forEach.\nWhile I could have used a simple for or while loop, I was more comfortable using array methods, so I started searching for a suitable method.\n1D Array (Array of N numbers)\nfor loop function createArray(n) { const result = [] for (let i = 1; i \u0026lt;= n; i++) { result.push(i) } return result } while loop function createArray(n) { const result = [] let i = 1 while (i \u0026lt;= n) { result.push(i) i++ } return result } Array.from //* Recommend const array = Array.from({ length: n }, (_, i) =\u0026gt; i + 1) Array.map const array = Array(n) .fill() .map((_, i) =\u0026gt; i + 1) Creating a 2D Array, e.g. [[1], [1,2], [1,2,3], [1,2,3,4], [1,2,3,4,5]]\nfor loop function createArrays(n) { const result = [] for (let i = 1; i \u0026lt;= n; i++) { const arr = [] for (let j = 1; j \u0026lt;= i; j++) { arr.push(j) } result.push(arr) } return result } while loop function createArrays(n) { const result = [] let i = 1 while (i \u0026lt;= n) { const arr = [] let j = 1 while (j \u0026lt;= i) { arr.push(j) j++ } result.push(arr) i++ } return result } Array.from //* Recommend function createArrays(n) { return Array.from({ length: n }, (_, i) =\u0026gt; Array.from({ length: i + 1 }, (_, j) =\u0026gt; j + 1) ) } Array.map function createArrays(n) { return Array(n) .fill() .map((_, i) =\u0026gt; Array(i + 1) .fill() .map((_, j) =\u0026gt; j + 1) ) } Creating an n x n 2D Array\nArray.from({ length: n }, () =\u0026gt; Array(n).fill(0)) ","permalink":"https://findmytrueself.github.io/en/algorithm/makearraywithnumber/","tags":["Algorithm","Javascript"],"title":"Creating an Array of N Numbers"},{"categories":null,"content":"Before addressing this question, I was studying the situation where functions enter the dependency array of useEffect.\nTypically, when creating a custom hook, the hook receives state values from the component\u0026rsquo;s props and uses them in the dependency array of useEffect for handling operations\nSo, what happens when a function is received as a prop? I contemplated this.\nWhy Functions Are Included in the Dependency Array\nWhenever a React component renders, functions are recreated.\nIn JavaScript, since functions are first-class objects, a function with the same name is treated as a different function each time it is recreated during rendering.\nTherefore, if a function is included in the dependency array, useEffect will run again every time that function is recreated during rendering.\nExample Using useCallback\nimport React, { useState, useEffect, useCallback } from \u0026#39;react\u0026#39; function SearchComponent() { const [searchQuery, setSearchQuery] = useState(\u0026#39;\u0026#39;) const [results, setResults] = useState([]) const fetchData = useCallback(() =\u0026gt; { fetch(`https://api.example.com/search?q=${searchQuery}`) .then((response) =\u0026gt; response.json()) .then((data) =\u0026gt; setResults(data.results)) .catch((error) =\u0026gt; console.error(\u0026#39;Error fetching data:\u0026#39;, error)) }, [searchQuery]) // fetchData function depends on searchQuery. useEffect(() =\u0026gt; { fetchData() }, [fetchData]) // fetchData is included in the dependency array. return ( \u0026lt;div\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; value={searchQuery} onChange={(e) =\u0026gt; setSearchQuery(e.target.value)} /\u0026gt; \u0026lt;ul\u0026gt; {results.map((result, index) =\u0026gt; ( \u0026lt;li key={index}\u0026gt;{result.name}\u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ) } export default SearchComponent Example Without Using useCallback\nimport React, { useState, useEffect } from \u0026#39;react\u0026#39; function SearchComponent() { const [searchQuery, setSearchQuery] = useState(\u0026#39;\u0026#39;) const [results, setResults] = useState([]) useEffect(() =\u0026gt; { const fetchData = () =\u0026gt; { fetch(`https://api.example.com/search?q=${searchQuery}`) .then((response) =\u0026gt; response.json()) .then((data) =\u0026gt; setResults(data.results)) .catch((error) =\u0026gt; console.error(\u0026#39;Error fetching data:\u0026#39;, error)) } fetchData() }, [searchQuery]) // useEffect runs every time searchQuery changes. return ( \u0026lt;div\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; value={searchQuery} onChange={(e) =\u0026gt; setSearchQuery(e.target.value)} /\u0026gt; \u0026lt;ul\u0026gt; {results.map((result, index) =\u0026gt; ( \u0026lt;li key={index}\u0026gt;{result.name}\u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ) } export default SearchComponent Differences\nFunction Creation and Memory Usage When a function is defined directly inside useEffect, it is newly defined every time useEffect runs due to changes in searchQuery. Because the function is recreated each time, memory usage may increase, and constantly redefining the function can lead to unnecessary computations. This difference can impact performance-sensitive applications, particularly in components that render frequently. Dependency Management If the function is not wrapped in useCallback, it is not included as a dependency in the dependency array. useEffect will only run when searchQuery changes. In this case, even though fetchData is newly defined every time searchQuery changes, dependency management is not complicated; it simply runs with the new function definition. Preventing Unnecessary Re-renders When using useCallback, the function is only recreated when values in the dependency array change. This helps prevent unnecessary re-renders of the component. Without useCallback, the fetchData function is recreated every time, leading to potential unintended re-renders in parts of the component managing other dependencies. When to Use useCallback\nComplex Components When managing many states: The component becomes complex when managing multiple states that interact with each other. For example, this occurs in form components with many input fields or UIs that dynamically change based on various events. When there are many child components: The complexity increases when a component renders multiple child components that exchange a lot of data, especially if those child components manage independent states or share the parent component\u0026rsquo;s state. When there is a lot of conditional rendering: The code can become complex with multiple conditional statements (if, switch, ternary operators) when rendering different UIs based on various conditions. Performance-Sensitive Situations Frequently rendered components: These components need to respond quickly, such as real-time updating dashboards, chat applications, or UIs with many animations. Handling large amounts of data: This situation arises when a component needs to process or render a lot of data at once, like rendering thousands of rows in a table or creating complex graphs. When optimization is needed: If certain operations occur frequently and negatively impact performance, optimization is necessary. This includes using React’s optimization hooks like React.memo, useCallback, and useMemo to reduce unnecessary re-renders. In these situations, if the component doesn\u0026rsquo;t operate efficiently, user experience can suffer, making it essential to optimize code or leverage React’s performance-related features.\nConclusion\nWhen Not Using useCallback: Defining and executing a function directly inside useEffect can lead to the function being recreated every time a value in the dependency array changes, impacting memory and performance. However, in simple situations, this might not be a significant issue. When Using useCallback: It helps prevent unnecessary re-creations of functions, contributing to performance optimization. This method is especially efficient if functions are frequently recreated. Thus, while there may not be a significant difference in small-scale components, using useCallback to memoize functions can be a better choice in complex components or performance-sensitive scenarios.\n","permalink":"https://findmytrueself.github.io/en/frontend/usecallback/","tags":["Javascript","React"],"title":"useCallback"},{"categories":null,"content":"flex-basis\nSimilar to width, it allows you to specify the initial size of the box.\nflex-grow\nYou can fill the available space in the overall box by giving it a value of 1. The default value is 0.\nflex-shrink\nIt allows you to dynamically reduce the size of the box. The default value is 1.\nflex-wrap\nIf the boxes exceed the screen width, they can be wrapped to the next line.\n","permalink":"https://findmytrueself.github.io/en/frontend/flexbox/","tags":["CSS"],"title":"FlexBox"},{"categories":null,"content":"September: Initial Setup and Code Analysis\nIn September 2022, I was tasked with renewing an existing blockchain wallet that had already been deployed on Chrome.\nWhen I first took on this project, I felt completely overwhelmed. The existing project was developed in Vue 2, and I had to modify it. Additionally, since Chrome follows the Manifest policy, I had to study that as well.\nThe Manifest v3 issue was there from the start, and since I was more familiar with React, I thought about rewriting the whole project from scratch. I attempted it, but I wasn’t confident enough to restructure everything from the ground up.\nThanks to my understanding of SPA structures, I was able to grasp the Vue 2 syntax and structure quickly, but Chrome development felt like a completely different domain compared to regular web development.\nI didn\u0026rsquo;t have enough resources, time, or skills to redevelop the already implemented features, so I reluctantly decided to refactor the existing code.\nOctober–November: Design Changes and Data Structure Modification\nThe design was updated from the simple previous version to a more vibrant one, and the flow changed significantly as well.\nMany of the features reused or slightly modified the existing code.\nSince the frontend doesn\u0026rsquo;t have a database, I used the browser\u0026rsquo;s storage to save data and retrieve it when needed.\nI refactored the system to fetch the data stored in Scan and display it to users. Any user-relevant data was stored in the storage for easy access.\nAll the states displayed in the view layer were managed in the Vuex store.\nFor asynchronous tasks, I used action dispatch and mutations commit methods to manage the state.\ngetters and computed properties were used to monitor state changes.\nDecember–January: Manifest Issue and Cause Identification\nIt had already been announced that, for security reasons, Google Chrome would require an upgrade to Manifest v3 by 2023.\nEven though we were aware of this issue, we continued developing, but it turned out to be a bigger problem than we expected.\nA serious issue arose: the entire background logic had to be rewritten.\nThe main reason why upgrading the manifest version was difficult was due to the blockchain SDK we were referencing. The SDK threw an unknown error that prevented the background script from being read.\nI reached out to the original foreign developer for help, and after the SDK was fixed, we were able to upgrade the Manifest version.\nFebruary: Background Logic Modification\nWith the Manifest version upgraded, the structure of the chrome.runtime object changed, and the background logic switched from running as an HTML page to a serviceworker.js file, which required significant changes.\nPreviously, the background script always stayed running, but due to security concerns, the new version automatically shut down background.js every 295 seconds. As a result, a logic to keep the background running was needed.\nAfter extensive research, I found a way to keep the background alive and applied it.\nPersistent Service Worker in Chrome Extension March: Preparing for Chrome Store Deployment and Bug Fixes\nIt\u0026rsquo;s time to focus on polishing the product details. By eliminating redundant logic from the previous implementation, I improved the stability of the extension.\nWhile testing with the QA team, we fixed numerous small bugs and refined the details. Now, we are preparing for the official release.\n","permalink":"https://findmytrueself.github.io/en/blockchain/blockchainwalletchromeextension/","tags":["Javascript","Web3","Blockchain"],"title":"Developing a Blockchain Wallet Chrome Extension"},{"categories":null,"content":" React Query efficiently manages data through unique keys, preventing duplicate fetch calls and improving performance. For example, if you create a fetch function via a custom hook, it will be called each time it\u0026rsquo;s used, leading to unnecessary calls for the same data.\nQuery Keys\nReact Query manages cached queries using query keys, organizing complex objects and long strings as arrays.\nSince these keys are serializable, they serve as unique identifiers for the cached data.\nuseQuery([\u0026#39;todos\u0026#39;], () =\u0026gt; {...}) useQuery([\u0026#39;todos\u0026#39;, 5, { preview : true }], () =\u0026gt; {...}) useQuery([\u0026#39;todos\u0026#39;, { type: \u0026#39;done\u0026#39;}], () =\u0026gt; {...}) By requesting desired data in an array, you create a unique key for caching the data. Example usage:\nconst Products = () =\u0026gt; { const [checked, setChecked] = useState(false) const { isLoading, error, data: products, } = useQuery([\u0026#39;products\u0026#39;, checked], async () =\u0026gt; { return fetch(`data/${checked ? \u0026#39;sale_\u0026#39; : \u0026#39;\u0026#39;}products.json`).then((res) =\u0026gt; res.json() ) }) } A fetch request is made when the checked state changes. Issues\nAlthough it may seem like caching is effective, you might notice in the console that duplicate data (such as already rendered UI or unchanged data) is repeatedly requested.\nKey Points of React Query\nReact Query is aggressively set up but also provides options for fine-tuning, which can be difficult for beginners to understand and debug.\nBy default, useQuery and useInfiniteQuery consider cached data as stale (stale: inactive or expired). The staleTime option can be set globally to control this behavior While staleTime is set, cached query data will not be refetched Refetching can occur under the following conditions:\nNew instances of the query mount The window is refocused The network is reconnected The query is optionally configured with a refetch interval If refetching happens unexpectedly, consider the window focus as a possible cause: The refetchOnWindowFocus feature is enabled by default, which can cause refetching when switching between tabs, especially when using dev tools. -\u0026gt; Adjust settings for refetchOnMount, refetchOnWindowFocus, refetchOnReconnect, and refetchInterval.\nIf useQuery or useInfiniteQuery are not used for a while, they will become inactive. After 5 minutes in this state, they will be automatically garbage collected. -\u0026gt; Change the cacheTime setting to a value greater than 1000 * 60 * 5 (5 minutes).\nWhen a query fails, it retries three times by default, with increasing intervals. -\u0026gt; Use the retry and retryDelay settings to control this behavior.\nData Communication Sequence Based on Stale State\nUpdating Data\nWhen updating, you can invalidate the existing query, which will automatically trigger a refetch.\nconst client = useQueryClient() \u0026lt;button onClick={()=\u0026gt;client.invalidateQueries([\u0026#39;products\u0026#39;, false])}\u0026gt;정보 업데이트 하기!\u0026lt;/button\u0026gt; Transitioning from Redux to React Query\nLink : [Transitioning from Redux to React Query][https://youtu.be/hcvcb36wzzk]\n","permalink":"https://findmytrueself.github.io/en/frontend/reactquery/","tags":["Javascript","React"],"title":"Overview of React Query"},{"categories":null,"content":"While using React, I mostly relied on the built-in hooks to handle most of my logic. However, I often pondered how to increase reusability for repetitive code.\nI believed that effectively using custom hooks would help me become a higher-level frontend developer.\nThe most important principle of custom hooks is \u0026ldquo;reusability of logic, not values.\u0026rdquo;\nBy specifying only the values related to state changes as parameters within the hook, we can define the logic based on side effects.\nimport { useState } from \u0026#39;react\u0026#39; function App() { const [inputValue, setInputValue] = useState(\u0026#39;\u0026#39;) const handleChange = (e) =\u0026gt; { setInputValue(e.target.value) } const handleSubmit = () =\u0026gt; { setInputValue(\u0026#39;\u0026#39;) } return ( \u0026lt;div\u0026gt; \u0026lt;input value={inputValue} onChange={handleChange} /\u0026gt; \u0026lt;button onClick={handleSubmit}\u0026gt;확인\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ) } Let\u0026rsquo;s convert the above code into a custom hook.\nimport { useState } from \u0026#39;react\u0026#39; export function useInput(initialValue, submitAction) { const [inputValue, setInputValue] = useState(initialValue) const handleChange = (e) =\u0026gt; { setInputValue(e.target.value) } const handleSubmit = () =\u0026gt; { setInputValue(\u0026#39;\u0026#39;) submitAction(inputValue) } return [inputValue, handleChange, handleSubmit] } import { useInput } from \u0026#39;hooks/useInput\u0026#39; function displayMessage(message) { alert(message) } function App() { const [inputValue, handleChange, handleSubmit] = useInput( \u0026#39;Hello\u0026#39;, displayMessage ) return ( \u0026lt;div\u0026gt; \u0026lt;input value={inputValue} onChange={handleChange} /\u0026gt; \u0026lt;button onClick={handleSubmit}\u0026gt;확인\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ) } import { useState, useEffect } from \u0026#39;react\u0026#39; const baseUrl = \u0026#39;https://jsonplaceholder.typicode.com\u0026#39; function App() { const [data, setData] = useState(null) const fetchUrl = (type) =\u0026gt; { fetch(baseUrl + \u0026#39;/\u0026#39; + type) .json() .then((res) =\u0026gt; { setData(res) }) } useEffect(() =\u0026gt; { fetchUrl(\u0026#39;users\u0026#39;) }, []) return ( \u0026lt;div\u0026gt; \u0026lt;button onClick={() =\u0026gt; fetchUrl(\u0026#39;users\u0026#39;)}\u0026gt;Users\u0026lt;/button\u0026gt; \u0026lt;button onClick={() =\u0026gt; fetchUrl(\u0026#39;posts\u0026#39;)}\u0026gt;Posts\u0026lt;/button\u0026gt; \u0026lt;button onClick={() =\u0026gt; fetchUrl(\u0026#39;todos\u0026#39;)}\u0026gt;Todos\u0026lt;/button\u0026gt; \u0026lt;pre\u0026gt;{JSON.stringify(data, null, 2)}\u0026lt;/pre\u0026gt; \u0026lt;/div\u0026gt; ) } Now, let\u0026rsquo;s refactor the above code using a custom hook.\nimport { useEffect, useState } from \u0026#39;react\u0026#39; export function useFetch(baseUrl, initialType) { const [data, setData] = useState(null) const fetchUrl = (type) =\u0026gt; { fetch(baseUrl + \u0026#39;/\u0026#39; + type) .json() .then((res) =\u0026gt; { setData(res) }) } useEffect(() =\u0026gt; { fetchUrl(initialType) }, []) return { data, fetchUrl, } } import { useFetch } from \u0026#39;hooks/useFetch\u0026#39; const baseUrl = \u0026#39;https://jsonplaceholder.typicode.com\u0026#39; function App() { const { data, fetchUrl } = useFetch(baseUrl, \u0026#39;users\u0026#39;) return ( \u0026lt;div\u0026gt; \u0026lt;button onClick={() =\u0026gt; fetchUrl(\u0026#39;users\u0026#39;)}\u0026gt;Users\u0026lt;/button\u0026gt; \u0026lt;button onClick={() =\u0026gt; fetchUrl(\u0026#39;posts\u0026#39;)}\u0026gt;Posts\u0026lt;/button\u0026gt; \u0026lt;button onClick={() =\u0026gt; fetchUrl(\u0026#39;todos\u0026#39;)}\u0026gt;Todos\u0026lt;/button\u0026gt; \u0026lt;pre\u0026gt;{JSON.stringify(data, null, 2)}\u0026lt;/pre\u0026gt; \u0026lt;/div\u0026gt; ) } import { useFetch } from \u0026#39;hooks/useFetch\u0026#39; const baseUrl = \u0026#39;https://jsonplaceholder.typicode.com\u0026#39; function App() { const { data: userData, fetchUrl } = useFetch(baseUrl, \u0026#39;users\u0026#39;) const { data: postData, fetchUrl } = useFetch(baseUrl, \u0026#39;posts\u0026#39;) const { data: todoData, fetchUrl } = useFetch(baseUrl, \u0026#39;todos\u0026#39;) return ( \u0026lt;div\u0026gt;{userData ? \u0026lt;pre\u0026gt;{JSON.stringify(userData[0], null, 2)}\u0026lt;/pre\u0026gt; : null}\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;{postData ? \u0026lt;pre\u0026gt;{JSON.stringify(postData[0], null, 2)}\u0026lt;/pre\u0026gt; : null}\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;{todoData ? \u0026lt;pre\u0026gt;{JSON.stringify(todoData[0], null, 2)}\u0026lt;/pre\u0026gt; : null}\u0026lt;/div\u0026gt; ) } ","permalink":"https://findmytrueself.github.io/en/frontend/reactcustomhooks/","tags":null,"title":"Understanding React Custom Hooks"},{"categories":null,"content":"Career Growth\nThis is the first word that comes to mind.\nAs a developer, the most frightening thing is to be stagnant.\nThese days, I often feel that way, so I plan to revive my blog and write consistently.\nI will revise the existing blog entries I wrote in Notion one by one and migrate them, and I will refer to many new topics on Medium to make them my own.\nI also need to avoid writing code like an amateur; I should think more deeply and aim to write it cleanly.\nHobbies\nThere are many things I want to do, but while struggling through life and thinking about realistic problems, I naturally ended up only sticking to light hobbies I can do at home.\nMany active hobbies require a car and money.\nWhen my friend Gevin visited, I tried snowboarding for the first time, and it was super fun. I plan to snowboard occasionally as a new hobby.\nI can do it alone. I have a motorcycle, so I can go to a nearby ski resort (about 30 km away) to enjoy it! The problem is money.\nPiano\nI have a digital piano that I bought two years ago. I believe that everyone should be able to play at least one instrument, and I hope to play the piano well.\nI learned piano without much thought when I was young, so I\u0026rsquo;ve forgotten all the theoretical aspects. Now, I memorize the entire score and practice until it becomes familiar to my hands.\nThat’s why it’s very hard to start learning, and the practice method is quite laborious.\nI think perseverance is essential in everything. My goal is to practice steadily, little by little.\nMoney\nBy next year, I need to save over 100 each month just to get by. I have to endure.\nPrices keep rising, so there’s a limit to how much money I can spend each month.\nIf I put in a bit more savings from here… I will really have nothing left.\nI hope the situation with CodeXXXX and unfair contracts can improve, but unfortunately, ignorance leads to suffering in capitalism.\nI hope the bull market returns so that my assets can at least increase a bit.\nExercise\nI stopped going to the gym last year, and I wasted more than half a year\u0026hellip; I feel so lethargic.\nIt’s a waste of money, and I worry about how to recover the muscle loss I\u0026rsquo;ve experienced.\nThere aren\u0026rsquo;t many places around my house where I can exercise, so it won\u0026rsquo;t be easy to keep going consistently.\n","permalink":"https://findmytrueself.github.io/en/diary/2023goal/","tags":null,"title":"2023 목표"},{"categories":null,"content":"The year filled with ups and downs is soon coming to an end.\nIn 2021, when I turned thirty, I only remember living fiercely for a year, betting everything on my goal of transitioning to a developer.\nAnd at the beginning of this year, January 2022, I found a suitable job that matched my aptitude.\nI came to Seoul carrying a few clothes and a nice coat that my mother bought to congratulate me on getting a job, all packed in a 27-inch suitcase.\nHaving had nothing, it took me quite a while to adapt to the new environment, and I needed to put in a lot of effort.\nAt first, I was constantly on edge, but things gradually improved. I was surrounded by good colleagues who supported me.\nWhile working at the company, I used the excuse of making a living to let many things slide.\nWork was one thing, but in the latter half of 2022, I did very little self-development.\nWhen coding, I should have thought twice or thrice before typing, but I was rushing to get things done quickly.\nAlso, I needed time to refine the code I had already written, which I was lacking.\nMoney\nHaving successfully landed a job, I felt momentarily happy receiving my salary, but I realized that salaried workers always seem to live on the edge.\nIf I hadn\u0026rsquo;t invested, I would have been able to live modestly by saving. The losses from my investments were quite significant.\nWhether in a bull market or a bear market, I found myself losing money, making me wonder if I shouldn\u0026rsquo;t be investing at all.\nDuring the bull market, I had easily succeeded as a beginner investor, gradually increasing my stakes and eventually using leverage that I couldn\u0026rsquo;t handle, resulting in losses.\nThis year started with a bear market, and I still don\u0026rsquo;t know the lowest point. Each time the market fell, I kept averaging down, and now most of my savings are in stocks and cryptocurrencies.\nAs much as I feel the risk, I believe I will become wealthy.\nFirst Move - Independence, Beginning of Hardships\nHaving had nothing, I thought it best to move into a goshiwon (a type of low-cost dormitory) near the company without any specific plan. There was no alternative.\nTo save on transportation costs, I looked for a goshiwon right in front of the company, but there were no vacancies, so I had to search elsewhere.\nEventually, I found a well-decorated goshiwon in the Moran area. Without knowing much, I went there without even seeing the room, as I had already brought my belongings and had no other choice.\nThe first month was a struggle as I tried to adapt to the company and living in the goshiwon.\nStaying in a one-room space with no windows, I personally experienced what it felt like to have claustrophobia.\nFortunately, I heard that a room had opened up in the goshiwon next to the company where I initially inquired. However, the price difference was enormous. The rent for a room with a window was almost 200,000 won more than the one without.\nAfter living there for a month, I thought it was definitely worth moving to a room with a window, but then another incident occurred on moving day.\nAs I was about to vacate after a month, my suitcase, which I had left in the common area, had disappeared.\nI was furious and determined to find the culprit. Since I had only lived there for a month, not many people were leaving, which helped narrow down the suspects.\nThe CCTV footage was poorly managed, so the goshiwon manager contacted those few suspects and got a confession (or rather an absurd claim that they had taken it by mistake).\nIt was a kid who looked about twenty years old, and despite their rude attitude, I weakened and let it go without punishment.\nSecond Move - The Journey to Finding a Jeonse\nMy second home was a small one-room with a bathroom, about 2-3 pyeong (approximately 6.6 to 9.9 square meters). Although it was a bit larger and had a window, it was still uncomfortable.\nHowever, the situation was similar; the goshiwon owner was quite picky, constantly staying around and grumbling.\nI still couldn’t make calls freely and had to live in frustration. I wanted to move quickly, but now I wanted a jeonse (a type of rental agreement in Korea), so I spent several months searching for one while working.\nThe building I was in was a commercial one, so I encountered many people in the elevator. During this time, I caught COVID-19.\nAt first, I was enjoying the salary and flexibly eating out nearby.\nBut the cost of living in that area was high, so I spent all my money eating out.\nIt didn\u0026rsquo;t seem like I was getting paid poorly, but the world treated me like I was.\nI decided to save as much as I could by stocking up on simple food that I could prepare myself.\nSometimes, I grilled meat in the common area, but the goshiwon owner gave me dirty looks. I wanted to move out quickly because of the owner.\nLooking back, it was around the peak of the real estate price surge, and jeonse prices were unreasonably high everywhere.\nI had too little to consider a regular jeonse.\nTherefore, since I had won the LH Youth Jeonse Loan in 2021, that was my only option. However, the LH eligibility review was extremely stringent.\nMost properties were already heavily mortgaged, so it was hard to find one suitable for LH approval. It seemed that only old villas built 20-30 years ago were available.\nDuring this time, I bought a small motorcycle for convenience in commuting. They said it had a fuel efficiency of 60 km per liter. These days, it’s too cold and dangerous to ride often.\nIn the spring and summer, I rode around looking at houses. I think I’ve seen almost all the places in the southern Gyeonggi area.\nI brainstormed how I could commute using the Shinbundang Line.\nThe area around the station was too expensive, so I looked for the best route to take the bus to the station.\nFortunately, I found a remodelable jeonse house eligible for LH loans. The walls hadn’t been repainted, but the layout seemed decent, so I signed the contract. It was a two-room, 14-pyeong (approximately 46.2 square meters) place.\nIt took about three months to complete the second move.\nThird Move\nSince the place was empty before I moved, I gradually transported my belongings using the motorcycle.\nAlthough it had a creepy appearance typical of old villas, the inside was nicely decorated. Since it was a jeonse house, it had no appliances or furniture, so I bought everything myself.\nAfter moving, I enjoyed the process of gradually assembling everything. I got many things from second-hand marketplaces, and for essential appliances like the washing machine, I felt uneasy about used items and the delivery fees, so I just bought new ones.\nBeing an old building, I worried about insects and insulation issues. The recent cold weather isn\u0026rsquo;t something that can be solved just by sticking bubble wrap on the windows. Nevertheless, I have to live here, so I plan to attach door seals and other items.\nStill, having my own space makes me comfortable at home. I always think that it was the best option given the situation.\nMy goal is to live in this house for a long time and save money to buy a property, but saving money is not easy.\nEvery payday, it feels like someone is taking my hard-earned money. Living with the greedy capitalists is not easy.\nEnd of COVID?\nCOVID seems endless.\nI remember posting about it after seeing a news report in December 2019. There were so many fake news stories that I thought it was absurd to have a plague like in the Middle Ages in the 21st century.\nBut it turned out to be true\u0026hellip; and even now, as we enter 2023, it’s still not over.\nAt the beginning of this year, South Korea practically implemented a “living with COVID” approach, and I caught it once, nearly dying.\nHaving contracted it less than a week after my third vaccine shot made me question the vaccine\u0026rsquo;s effectiveness.\nChina is just now starting to implement a “living with COVID” approach, and it’s said that over half the population has already contracted it. The stock market has risen again, and I hope everything returns to normal quickly.\nReflection\nIf you ask me whether I grew a lot this year, I would say it’s half right and half wrong.\nThis year, I only remember struggling for survival. It was probably the most unstable and hardest period of my life.\nStill, I’ve been lucky enough to endure until now, and I seem to be living well despite the worst circumstances.\nIf I want to establish my career as a developer, I need to set aside my immediate worries and try to have more peace of mind.`\n","permalink":"https://findmytrueself.github.io/en/diary/2022retrospect/","tags":null,"title":"2022 Reflection"},{"categories":null,"content":" createAsyncThunk allows you to create actions for handling asynchronous operations. const asyncUpFetch = createAsyncThunk(\u0026#39;counterSlice/asyncUpFetch\u0026#39;, async () =\u0026gt; { const resp = await fetch(\u0026#39;https://api.aergo.io/~~\u0026#39;) const data = await resp.json() return data.value }) createAsyncThunk Flow While reducers automatically create action creators for you, this is not the case for asynchronous operations. You need to create the action creators manually within extraReducers. ","permalink":"https://findmytrueself.github.io/en/frontend/reduxthunk/","tags":["Javascript","React"],"title":"Overview of Redux Thunk"},{"categories":null,"content":"\u0026lt;Button variant=\u0026#34;contained\u0026#34; component=\u0026#34;label\u0026#34;\u0026gt; Upload Icon \u0026lt;input accept=\u0026#34;image/*\u0026#34; multiple type=\u0026#34;file\u0026#34; hidden onChange={(e: ChangeEvent\u0026lt;HTMLInputElement\u0026gt;): void =\u0026gt; handleUploadIcon(e)} /\u0026gt; \u0026lt;/Button\u0026gt; First, we create an upload button that accepts all images and creates an input tag of type file.\nconst handleUploadIcon = (e: ChangeEvent\u0026lt;HTMLInputElement\u0026gt;) =\u0026gt; { setImgFile(e.target.files[0]) const imagePromise = e.target.files[0].arrayBuffer().then((buf) =\u0026gt; { return makeImage(buf, figure, borderColor) }) imagePromise.then((resized) =\u0026gt; { const fileReader = new FileReader() fileReader.readAsDataURL(resized) fileReader.onload = (e) =\u0026gt; { const image = new Image() image.src = e.target.result as string image.onload = () =\u0026gt; { const base64Img = e.target.result as string // //! Convert icon to hash const hash = CryptoJS.SHA256(base64Img).toString() const file = dataURLtoFile(base64Img, \u0026#39;MaskedImage.png\u0026#39;) dispatch(setInfo(base64Img, \u0026#39;base64Img\u0026#39;)) dispatch(setInfo(hash, \u0026#39;Icon Added\u0026#39;)) setFile(file) } } }) } We use the makeImage function to mask the image and the dataURLtoFile function to create a file object.\nuseEffect(() =\u0026gt; { if (imgFile) { const imagePromise = imgFile.arrayBuffer().then((buf: ArrayBuffer) =\u0026gt; { return makeImage(buf, figure, borderColor) }) imagePromise.then((resized: Blob) =\u0026gt; { const fileReader = new FileReader() fileReader.readAsDataURL(resized) fileReader.onload = (e) =\u0026gt; { const image = new Image() image.src = e.target.result as string image.onload = () =\u0026gt; { const base64Img = e.target.result as string const hash = CryptoJS.SHA256(base64Img).toString() const file = dataURLtoFile(base64Img, \u0026#39;MaskedImage.png\u0026#39;) dispatch(setInfo(base64Img, \u0026#39;base64Img\u0026#39;)) dispatch(setInfo(hash, \u0026#39;아이콘 추가\u0026#39;)) setFile(file) } } }) } }, [borderImgState, borderColor]) useEffect(() =\u0026gt; { if (icon \u0026amp;\u0026amp; file) { dispatch(setInfo(file, \u0026#39;uploadFile\u0026#39;)) dispatch(setInfo(borderImg, \u0026#39;borderImgState\u0026#39;)) dispatch(setInfo(borderColor, \u0026#39;borderColor\u0026#39;)) } }, [icon, file]) The masking function is executed every time the border or image changes.\n/* eslint-disable func-names */ /* eslint-disable no-bitwise */ /* eslint-disable no-plusplus */ import { Image as ImageJS } from \u0026#39;image-js\u0026#39; import { lineURL, pngURL } from \u0026#39;../../components/TokenDeploy/MakeSymbol\u0026#39; const BASE_SIZE = 640 async function makeImage( imgBytes: ArrayBuffer, templateNum: number, borderColor: string ) { // 1. load image from bytes const originalImg = await ImageJS.load(imgBytes) const emptyArr = new Array(640 * 640 * 4).fill(0) const bg = new ImageJS(BASE_SIZE, BASE_SIZE, emptyArr, { alpha: 1 }) console.log( \u0026#39;original originalImg info\u0026#39;, originalImg.width, originalImg.height ) // 2. resize image let xOffset = 0 let yOffset = 0 let resizedImg: ImageJS if (originalImg.width \u0026gt; originalImg.height) { resizedImg = originalImg.resize({ width: BASE_SIZE }) yOffset = (BASE_SIZE - resizedImg.height) / 2 } else { resizedImg = originalImg.resize({ height: BASE_SIZE }) xOffset = (BASE_SIZE - resizedImg.width) / 2 } const squaredImg = await mergeImages(bg, xOffset, yOffset, resizedImg) // 3. make maskImage const maskOriginal = await makeMaskImage(templateNum) const mask: ImageJS = maskOriginal // @ts-ignore .gray() .mask({ threshold: 0.1, useAlpha: true }) // 4. extract by mask // @ts-ignore const maskedImage = await squaredImg.extract(mask, { position: [0, 0] }) // 5. draw border image const borderImg = await makeBorderImage(templateNum, borderColor) const borderAddedImage = await mergeImages(maskedImage, 0, 0, borderImg) // Return as blob type return borderAddedImage.toBlob() } async function makeMaskImage(templateNumber: number): Promise\u0026lt;ImageJS\u0026gt; { const borderMaskFile = pngURL[templateNumber] const maskUrl = `${borderMaskFile}` return new Promise\u0026lt;ImageJS\u0026gt;(function (resolve, reject) { const xhr = new XMLHttpRequest() xhr.open(\u0026#39;get\u0026#39;, maskUrl) xhr.responseType = \u0026#39;arraybuffer\u0026#39; xhr.onload = function () { ImageJS.load(xhr.response).then((mask) =\u0026gt; resolve(mask)) } xhr.onerror = function () { reject(new Error(`failed by ${this.status}`)) } xhr.send() }) } // * Coloring. async function makeBorderImage( templateNumber: number, borderColor: string ): Promise\u0026lt;ImageJS\u0026gt; { const rawBorderMask = await loadBorderImage(templateNumber) // @ts-ignore const mask = rawBorderMask.gray().mask({ threshold: 0.1, useAlpha: true }) const background = new ImageJS(BASE_SIZE, BASE_SIZE, [], { alpha: 1 }) // @ts-ignore const maskedBorder = background.extract(mask, { position: [0, 0] }) const border = maskedBorder.paintMasks(mask, { color: borderColor }) return border } // * Load image. async function loadBorderImage(templateNumber: number): Promise\u0026lt;ImageJS\u0026gt; { const borderMaskFile = lineURL[templateNumber] const borderUrl = `${borderMaskFile}` return new Promise\u0026lt;ImageJS\u0026gt;(function (resolve, reject) { const xhr = new XMLHttpRequest() xhr.open(\u0026#39;get\u0026#39;, borderUrl) xhr.responseType = \u0026#39;arraybuffer\u0026#39; xhr.onload = function () { ImageJS.load(xhr.response).then((mask) =\u0026gt; resolve(mask)) } xhr.onerror = function () { reject(new Error(`failed by ${this.status}`)) } xhr.send() }) } async function mergeImages( out: ImageJS, x: number, y: number, toInsert: ImageJS ) { const maxY = Math.min(out.height, y + toInsert.height) const maxX = Math.min(out.width, x + toInsert.width) if (out.bitDepth === 1) { for (let j = y; j \u0026lt; maxY; j++) { for (let i = x; i \u0026lt; maxX; i++) { const val = toInsert.getBitXY(i - x, j - y) if (val) out.setBitXY(i, j) else out.clearBitXY(i, j) } } } else { for (let j = y; j \u0026lt; maxY; j++) { for (let i = x; i \u0026lt; maxX; i++) { if (toInsert.getPixelXY(i - x, j - y)[3] \u0026gt; 127) { out.setPixelXY(i, j, toInsert.getPixelXY(i - x, j - y)) } } } } return out } export default makeImage const dataURLtoFile = (base64: string, fileName: string) =\u0026gt; { const arr = base64.split(\u0026#39;,\u0026#39;) const mime = arr[0].match(/:(.*?);/)[1] const bstr = window.atob(arr[1]) let n = bstr.length const u8arr = new Uint8Array(n) while (n--) { u8arr[n] = bstr.charCodeAt(n) } const file = new File([u8arr], `${fileName}.png`, { type: mime }) return file } ","permalink":"https://findmytrueself.github.io/en/frontend/imgmask/","tags":["Javascript","React"],"title":"Image Masking in React"},{"categories":null,"content":"These days, the reality is that in order to earn a salary, one must come to the metropolitan area.\nOtherwise, you either have to work for a public enterprise, run a business, or do casual or part-time jobs.\nSo, people like me have no choice but to come to the metropolitan area to survive. However, I have no connections here at all.\nUltimately, if I want to live, I need to establish myself in the metropolitan area, but that’s when I have to constantly grapple with housing issues.\nTo Survive\nHave you thought about your monthly fixed expenses?\nAmong these, the largest cost is housing, which is money that goes out just for breathing.\nIn fact, what is the reason we earn money?\nI believe we earn money to seek a better quality of life.\nTo improve the quality of life, I need to save a lump sum, but in this place, just breathing incurs expenses.\nMaking money is not easy, but spending it is all too simple.\nThe Reason I Took Out the LH Jeonse Loan\nBack in 2021, when I was studying development, I often wondered how I could buy a better and cheaper house in the future, so I browsed various sites.\nAmong them, I first applied for the Happy Housing in Mapo and then for the LH 3rd priority.\nI assumed that the Happy Housing in Mapo would be competing against people from the metropolitan area and the same district, so I applied for a shared unit.\nFortunately, LH had a lucky 3rd priority selection process, allowing me to apply as a young person or job seeker since my income hadn’t been assessed.\nAfter that, there was no news for several months.\nBy that time, I had already secured employment and was anxiously moving between different goshiwons (one-room accommodations).\nThe really frustrating thing is that just because it\u0026rsquo;s a goshiwon doesn’t mean the rent is cheap.\nHow Did I Search for a House?\nCurrently, my workplace is located in Bundang, and while I was considering whether I could still go for the Happy Housing I applied for in Mapo, I ended up getting an income during the review process, which disqualified me from the Happy Housing list.\nThe only options left were the LH Jeonse loan, general youth jeonse loan, or the Didiimdol jeonse loan.\nIn fact, the only places that provide 100% of the jeonse loan are the LH Jeonse loan and the small business youth loan.\nIronically, finding a room where 100% of the loan is available is harder than finding a needle in a haystack.\nAll the houses that seemed decent were not eligible.\nSo, while working, I made time to ride my motorcycle and checked out almost all the houses in southern Gyeonggi Province.\nI wanted to find a house as close to Bundang as possible, but there was so much demand for LH or small business loans in Bundang that almost all of them were not available.\nFurthermore, with interest rates continuing to rise, I was worried about managing the interest if I took out a different loan, and I was also afraid of falling victim to rental scams.\nSo, I had very few options: either a low deposit with monthly rent or using the LH Jeonse loan.\nAdvantages of LH Jeonse Loan\nThere’s no risk of rental scams.\nThis is because the loan is not based on a contract between me and the landlord but rather a contract between LH Corporation and the landlord.\nThis allows for a high level of trust when signing the contract.\nOnce the rights analysis is approved, the attorney will handle everything on the contract date.\n100% Jeonse Loan\nThese days, house prices are incredibly high, so even if you get an 80% loan for a house worth 100 million KRW, you’ll still need 20 million KRW.\nBut the funny thing is that a house with a 100 million KRW jeonse that’s available for loan is unlikely to be a good one.\nIn fact, considering the interest, there’s hardly any difference from monthly rent.\nIn some cases, renting might actually be more beneficial since you won’t fall victim to rental scams.\nThe LH Jeonse loan provides a 100% loan with a fixed interest rate of 2%. Depending on the individual, a preferential interest rate of 0.5% can also be applied.\nDisadvantages of LH Jeonse Loan\nYou have to live in houses that people generally don’t want to stay in.\nSince my primary goal was to minimize my rent, I had to rely on LH as much as possible.\nSo, when I went to see rooms, I thought I could just settle for any decent place. But to my shock, there were so many houses in terrible condition.\nHowever, it was really hard to find something decent, which was disappointing enough to make me consider giving up on LH altogether.\nHow I Ended Up Finding a Room\nWhile exploring various neighborhoods, I tried to find a place as close to the Shinbundang Line as possible.\nIf I could take the Shinbundang Line, I could easily access Gangnam, Pangyo, Jeongja (where my company is), and Gwanggyo, and the line is expected to expand further.\nOf course, the prices are higher in that area, but when I use the Shinbundang Line, the quality of life improves.\nSo while looking at rooms accessible by bus, I discovered a building undergoing a full renovation.\nAlthough the building was old, the two-room unit was clean inside, so I judged that it was the best option given my situation and signed the contract immediately.\nI ended up choosing a semi-jeonse option, which requires paying a bit more in rent, but I felt it was better than not finding a place at all.\nThe downside is that there are no options included, so I have to purchase everything myself.\nNow I am waiting for the move-in date. My commuting time will increase, but in the future, I plan to work from home occasionally to try to minimize my commuting time.\nReflections\nSince I have mostly lived in apartments, I haven’t experienced the inconveniences of living in villas, but I expect to feel that as I continue living here.\nStill, I feel proud that I was able to find a home on my own.\nWith so much money taken from CodeXXXX, my priority was to minimize my monthly expenses.\nWith more space, my quality of life will naturally improve, and I expect to have more activities I can do at home.\n","permalink":"https://findmytrueself.github.io/en/diary/lh/","tags":null,"title":"Finding a Home with LH Jeonse Loan"},{"categories":null,"content":"Throughout my projects, I\u0026rsquo;ve used Redux for state management.\nThere are many state management libraries available. Recently, I’ve heard of libraries like MobX, Recoil, Zustand, and so on.\nWhile I haven\u0026rsquo;t applied other state management solutions directly in my projects, the statistics indicate that Redux is overwhelmingly popular.\nSo far, I haven’t experienced significant inconvenience while using React and Redux.\nHowever, I found the back-and-forth process of changing type definitions, action functions, and reducers in Redux to be cumbersome.\nWhen upgrading to React 18, I discovered that the syntax I had been using was considered \u0026ldquo;legacy.\u0026rdquo; I vaguely understood that the Redux Toolkit library could alleviate the inconveniences of traditional Redux.\nAt the time, I was busy with development and tried to apply the methods I found on blogs without thoroughly reading the official documentation.\nUltimately, I failed to refactor my existing Redux code and decided to revert to my well-structured existing Redux code, which I deemed to be fine.\nFor this new project, I want to explore Redux Toolkit from the beginning, so I’m summarizing my findings here.\nRedux\nRedux is a state container The state of the application can change In redux, a pattern is enforced to ensure all state transitions are explicit and can be tracked The changes to your application\u0026rsquo;s state become predictable If you want to manage the global state of your application in a predictable way, redux can help you The patterns and tools provided by Redux make it easier to understand, when, where, why, and how the state in your application is being updated, and how your application logic will behave when those changes occur Redux guides you towords writing code that is predictable and testable, which helps give you confidence that your application will work as exected Redux Toolkit\nRedux toolkit is the officail, opinionated, batteries-included toolset for efficient Redux development. It is also intended to be the standard way to write Redux logic in your application Why Use Redux Toolkit?\nRedux is great, but it does have a few shortcomings, Configuring redux in an app seems complicated. In addition to redux, a lot of other packages have to be installed to get redux to do something useful. Redux requires too much boilerplate code Redux toolkit serves as an abstraction over redux. It hides the difficult parts ensuring you have a good developer experience. When Should You Use Redux?\nYou have large amounts of application state that are needed in many places in the app The app state is updated frequently over time The logic to update that state may be complex The app has a medium or large-sized codebase, and might be worked on by many people Immer Library\n리덕스 객체를 다룰때, immutable을 유지하기 위해 rest parameter 혹은 배열의 내장함수를 이용해서 불변성을 구현 할 수 있지만, 코드가 복잡해지는 단점이 있다.\nimmer가 이러한 불변성을 관리 해준다.\nThree Key Concepts\nstore : holds the state of your application. action : describes what happened in the application reducer : handles the action and decides how to update the state Redux Toolkit Syntax\nCreating a Store: import { configureStore } from \u0026#34;@reduxjs/toolkit\u0026#34;; // ... export const store = configureStore({ reducer: { posts: postsReducer, comments: commentsReducer, users: usersReducer, }, }); // Infer the `RootState` and `AppDispatch` types from the store itself export type RootState = ReturnType\u0026lt;typeof store.getState\u0026gt;; // Inferred type: {posts: PostsState, comments: CommentsState, users: UsersState} export type AppDispatch = typeof store.dispatch; Advantages\nUsing Hooks: There was a cumbersome problem of having to declare types every time when using useDispatch and useSelector. By using hooks, we can eliminate this boilerplate code! // hooks/index.ts import { TypedUseSelectorHook, useDispatch, useSelector } from \u0026#34;react-redux\u0026#34;; import type { RootState, AppDispatch } from \u0026#34;./store\u0026#34;; // Use throughout your app instead of plain `useDispatch` and `useSelector` export const useAppDispatch = () =\u0026gt; useDispatch\u0026lt;AppDispatch\u0026gt;(); export const useAppSelector: TypedUseSelectorHook\u0026lt;RootState\u0026gt; = useSelector; //? Component that dispatches actions import { useAppDispatch } from \u0026#34;hooks\u0026#34;; const dispatch = useAppDispatch(); dispatch(리듀서함수()); CreateSlice Syntax: import { createSlice, PayloadAction } from \u0026#34;@reduxjs/toolkit\u0026#34;; import type { RootState } from \u0026#34;../../app/store\u0026#34;; // Define a type for the slice state interface CounterState { value: number; } // Define the initial state using that type const initialState: CounterState = { value: 0, }; export const counterSlice = createSlice({ name: \u0026#34;counter\u0026#34;, // `createSlice` will infer the state type from the `initialState` argument initialState, reducers: { increment: (state) =\u0026gt; { state.value += 1; }, decrement: (state) =\u0026gt; { state.value -= 1; }, // Use the PayloadAction type to declare the contents of `action.payload` incrementByAmount: (state, action: PayloadAction\u0026lt;number\u0026gt;) =\u0026gt; { state.value += action.payload; }, }, }); export const { increment, decrement, incrementByAmount } = counterSlice.actions; // Other code such as selectors can use the imported `RootState` type export const selectCount = (state: RootState) =\u0026gt; state.counter.value; export default counterSlice.reducer; After this, you just need to dispatch the action functions you want to use.\n","permalink":"https://findmytrueself.github.io/en/frontend/reduxtoolkit/","tags":["React"],"title":"Trying Out Redux Toolkit"},{"categories":null,"content":"Promise\nThe Promise object, introduced in JavaScript ES6, was first created to solve the \u0026ldquo;callback hell\u0026rdquo; problem, which arises when callback functions accumulate during asynchronous operations.\nWhile it works on the same principle, the Promise object provides better readability, which is why it is utilized. However, using many promise variables can lead to experiencing \u0026ldquo;promise hell\u0026rdquo; as well.\nResponse Time of Callback Functions, Promises, and Async/Await\nThe response time for both callback functions and promises is almost identical. They are read sequentially in the initial hoisting environment, causing the asynchronous part to be read before the previous processes are complete.\nThus, even if there is a delay with functions like setTimeout, the response time disregards the delay and processes the next lines first.\nThe reason the response time for callback functions and promises is almost the same is due to slight speed differences caused by the browser\u0026rsquo;s environment.\nOverall, the response time for async/await is the slowest because it waits for all asynchronous tasks (like setTimeout) to finish before proceeding in order.\nCallback Functions\nTo understand callback functions, one must first understand \u0026ldquo;hoisting.\u0026rdquo;\nHoisting\nHoisting is the process of elevating all declarations within a function to the top of the function\u0026rsquo;s scope.\nAll necessary values for the function are declared at the top before the function executes.\nsetTimeout(callback , time)\nA browser API that outputs the callback function after a specified time (in milliseconds).\nSynchronous vs. Asynchronous\nJavaScript is synchronous.\nSynchronous callback\nconsole.log(\u0026#39;1\u0026#39;) setTimeout(() =\u0026gt; console.log(\u0026#39;2\u0026#39;), 1000) console.log(\u0026#39;3\u0026#39;) function printImmediately(print) { print() } printImmediately(() =\u0026gt; console.log(\u0026#39;hello\u0026#39;)) Hoisting result:\nfunction printImmediately(print) { // 1. Hoisting function declaration print() } console.log(\u0026#39;1\u0026#39;) // 2. Outputs \u0026#39;1\u0026#39; setTimeout(() =\u0026gt; console.log(\u0026#39;2\u0026#39;), 1000) // 3. Requests to output \u0026#39;2\u0026#39; after 1 second console.log(\u0026#39;3\u0026#39;) // 4. Outputs \u0026#39;3\u0026#39; printImmediately(() =\u0026gt; console.log(\u0026#39;hello\u0026#39;)) // 5. Immediately executes function, outputs \u0026#39;hello\u0026#39; // 6. Outputs \u0026#39;2\u0026#39; after 1 second, per browser API Asynchronous callback\nconsole.log(\u0026#39;1\u0026#39;) setTimeout(() =\u0026gt; console.log(\u0026#39;2\u0026#39;), 1000) console.log(\u0026#39;3\u0026#39;) function printImmediately(print) { print() } printImmediately(() =\u0026gt; console.log(\u0026#39;hello\u0026#39;)) function printWithDelay(print, timeout) { setTimeout(print, timeout) } printWithDelay(() =\u0026gt; console.log(\u0026#39;async callback\u0026#39;), 2000) Hoisting result:\nfunction printImmediately(print) { print() } function printWithDelay(print, timeout) { setTimeout(print, timeout) } console.log(\u0026#39;1\u0026#39;) // Synchronous setTimeout(() =\u0026gt; console.log(\u0026#39;2\u0026#39;), 1000) // Asynchronous ------------\u0026gt; console.log(\u0026#39;3\u0026#39;) // Synchronous printImmediately(() =\u0026gt; console.log(\u0026#39;hello\u0026#39;)) // Synchronous printWithDelay(() =\u0026gt; console.log(\u0026#39;async callback\u0026#39;), 2000) // Asynchronous ------------\u0026gt; Promise\nA Promise is \u0026ldquo;an object that can handle asynchronous states as values.\u0026rdquo;\nWhy are promises needed?\nPromises are mainly used to display data received from servers. Generally, when implementing web applications, APIs are used to request and retrieve data from servers.\nProblems with Callback Patterns\nNested use of callback functions function requestData1(callback) { callback(data) // 2 } function requestData2(callback) { callback(data) // 4 } function onSuccess1(data) { console.log(data) requestData2(onSuccess2) // 3 } function onSuccess2(data) { // 5 console.log(data) } requestData1(onSuccess1) // 1 // The flow of callback pattern code is not sequential, making it hard to read. Simple Promise code example requestData1() .then((data) =\u0026gt; { console.log(data) return requestData2() }) .then((data) =\u0026gt; { console.log(data) }) Three states of a Promise pending: waiting fulfilled: completed normally with a result rejected: completed abnormally. settled: either fulfilled or rejected state. Once a promise is settled, it cannot change to another state. It can only change from pending to fulfilled or rejected. How to create a Promise const p1 = new Promise((resolve, reject) =\u0026gt; { resolve(data) // or reject(\u0026#39;error message\u0026#39;) }) const p2 = Promise.reject(\u0026#39;error message\u0026#39;) const p3 = Promise.resolve(param) Promise.resolve return value const p1 = Promise.resolve(123) console.log(p1 !== 123) // true 이행됨 상태인 프로미스가 반환된다. const p2 = new Promise((resolve) =\u0026gt; setTimeout(() =\u0026gt; resolve(10), 1)) console.log(Promise.resolve(p2) === p2) // true // Promise.resolve 함수에 프로미스가 입력되면 그 자신이 반환된다. Using Promises: .then The then method is used when handling a fulfilled promise. //requestData().then(onResolve, onReject); // When the promise becomes fulfilled, the onResolve function is called; if rejected, the onReject function is called. Promise.resolve(123).then((data) =\u0026gt; console.log(data)) // 123 Promise.reject(\u0026#39;err\u0026#39;).then(null, (error) =\u0026gt; console.log(error)) // err Chaining multiple .then calls let requestData1 = new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { resolve(\u0026#39;hun\u0026#39;) }, 1000) }) let requestData2 = new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { resolve(\u0026#39;jenny\u0026#39;) }, 2000) }) requestData1 .then((data) =\u0026gt; { console.log(data) return requestData2 // 1 }) .then((data) =\u0026gt; { return data + 1 // 2 }) .then((data) =\u0026gt; { throw new Error(\u0026#39;some Error\u0026#39;) // 3 }) .then(null, (error) =\u0026gt; { console.log(error) }) When a promise is returned from a function, the then method returns that value as is. If a non-promise value is returned, the then method returns a fulfilled promise. If an exception occurs within the function, the then method returns a rejected promise. If it becomes a rejected state, the onReject function is called. Promise.reject(\u0026#39;err\u0026#39;) .then(() =\u0026gt; console.log(\u0026#39;then 1\u0026#39;)) // 1 .then(() =\u0026gt; console.log(\u0026#39;then 2\u0026#39;)) // 1 .then( () =\u0026gt; console.log(\u0026#39;then 3\u0026#39;), () =\u0026gt; console.log(\u0026#39;then 4\u0026#39;) ) // 2 .then( () =\u0026gt; console.log(\u0026#39;then 5\u0026#39;), () =\u0026gt; console.log(\u0026#39;then 6\u0026#39;) ) // 3 Since the promise is rejected, the first encountered onReject function is called, making the first instance omitted, and the then 4 from the second code outputs. The function that prints then 4 has undefined as its result, which creates a fulfilled promise. Therefore, then 5 is printed in the subsequent then method. The most important characteristic of the then method is that it is always called in the order it is chained.\nUsing Promises 2: catch Catch is a method for handling exceptions that occur during promise execution. The catch method serves the same purpose as the onReject function of the then method. javascript 코드 복사 Promise.reject(1).then(null, (error) =\u0026gt; { console.log(error) }) Promise.reject(1).catch((error) =\u0026gt; { console.log(error) }) For readability, it’s better to use the catch method for exception handling than the onReject function of then. Problems when using the onReject function of then. javascript 코드 복사 Promise.resolve().then( () =\u0026gt; { // 1 throw new Error(\u0026lsquo;some error\u0026rsquo;) }, (error) =\u0026gt; { // 2 console.log(error) } ) The exception raised in the resolve function of the first then is not handled by the reject function of the same then. Executing this will result in an Unhandled promise rejection error because the rejected promise was not handled.\nAn example using catch instead of the onReject function.\nPromise.reject(1).then(null, (error) =\u0026gt; { console.log(error) }) Promise.reject(1).catch((error) =\u0026gt; { console.log(error) }) For readability, it’s better to use the catch method for exception handling than the onReject function of then.\nProblems when using the onReject function of then. Promise.resolve().then( () =\u0026gt; { // 1 throw new Error(\u0026#39;some error\u0026#39;) }, (error) =\u0026gt; { // 2 console.log(error) } ) The exception raised in the resolve function of the first then is not handled by the reject function of the same then. Executing this will result in an Unhandled promise rejection error because the rejected promise was not handled.\nAn example using catch instead of the onReject function. Promise.resolve() .then(() =\u0026gt; { throw new Error(\u0026#39;some error\u0026#39;) }) .catch((error) =\u0026gt; { console.log(error) }) Using then after catch Promise.reject(10) .then((data) =\u0026gt; { console.log(\u0026#39;then1:\u0026#39;, data) return 20 }) .catch((error) =\u0026gt; { console.log(\u0026#39;catch:\u0026#39;, error) return 30 }) .then((data) =\u0026gt; { console.log(\u0026#39;then2:\u0026#39;, data) }) // catch: 10 // then2: 30 Using Promises 3: Finally A simple code example using finally: requestData() .then(data =\u0026gt; { ... }) .catch(error =\u0026gt; { ... }) .finally(() =\u0026gt; { ... }); The finally method does not create a new promise. function requestData(){ return fetch() .catch(error =\u0026gt; { ... }) .finally(() =\u0026gt; { senLogToServer(\u0026#39;requestData finished\u0026#39;) }) } requestData().then(data =\u0026gt; console.log(data)); // 1번 In the first case, the return value of the requestData function is the promise before the finally method is called. Therefore, as a user of the requestData function, you don\u0026rsquo;t have to worry about the existence of the finally method.\nUsing Promises Effectively\nHandling in Parallel: Promise.all\nPromise.all is a function used for processing multiple promises in parallel. By chaining the then method, you can overcome the drawback of asynchronous processes being executed sequentially.\nAsynchronous code executed sequentially: requestData1() .then((data) =\u0026gt; { console.log(data) return requestData2() }) .then((data) =\u0026gt; { console.log(data) }) If there is no dependency between asynchronous functions, processing them in parallel is faster. By calling the asynchronous functions separately without chaining the then method, they will be processed in parallel.\nCode executed in parallel: requestData1().then((data) =\u0026gt; { console.log(data) }) requestData2().then((data) =\u0026gt; { console.log(data) }) requestData1 and requestData2 run simultaneously. If you want to process multiple promises in parallel, use Promise.al\nCode using Promise.all: Promise.all([requestData1(), requestData2()]).then(([data1, data2]) =\u0026gt; { console.log(data1, data2) }) The Promise.all function returns a promise. The promise returned by Promise.all will only become fulfilled when all the input promises are fulfilled. If any promise is rejected, the promise returned by Promise.all will also be in the rejected state.\nGetting the Fastest Processed Promise: Promise.race\nWhen any promise input to the Promise.race function becomes fulfilled, the promise returned by Promise.race also becomes fulfilled.\nSimple code using Promise.race: Promise.race([ requestData(), new Promise((_, reject) =\u0026gt; setTimeout(reject, 3000)), ]) .then((data) =\u0026gt; console.log(data)) .catch((error) =\u0026gt; console.log(error)) If the requestData function receives data within 3 seconds, the then method is called; otherwise, the catch method is called.\nData Caching Using Promises\nBy leveraging the property of promises that maintain their state when fulfilled, you can cache data.\nImplementing caching functionality with promises: let cachedPromise function getData() { cachedPromise = cachedPromise || requestData() // 1번 return cachedPromise } getData().then((v) =\u0026gt; console.log(v)) getData().then((v) =\u0026gt; console.log(v)) n the first instance, when the getData function is called for the first time, requestData is invoked. Once the data retrieval task is complete, the result is stored in the cachedPromise.\nCautions When Using Promises\nDon\u0026rsquo;t forget the return keyword. It\u0026rsquo;s easy to forget to input the return keyword in the internal function of the then method. The data of the promise object returned by the then method is the value returned by the internal function. If you don\u0026rsquo;t use the return keyword, the data of the promise object will be undefined.\nCode that forgets the return keyword:\nPromise.resolve(10) .then((data) =\u0026gt; { console.log(data) Promise.resolve(20) // 2번 }) .then((data) =\u0026gt; { console.log(data) // 1번 }) In the first instance, undefined is printed contrary to the intention. If you input the return keyword in the second piece of code, 20 will be printed as intended.\nRemember that promises are immutable objects. Promises are immutable objects.\nCode written thinking that a promise can be modified:\nfunction requestData() { const p = Promise.resolve(10) p.then(() =\u0026gt; { // 1 return 20 }) return p } requestData().then((v) =\u0026gt; { console.log(v) // 10 // 2 }) The then method does not modify the existing object; it returns a new promise. In the second case, if you want 20 to be printed, you need to modify the requestData function as follows.\nCode returning the promise created by the then method: function requestData() { return Promise.resolve(10).then((v) =\u0026gt; { return 20 }) } Avoid using nested promises. Using nested promises can lead to \u0026ldquo;promise hell\u0026rdquo; similar to callback hell.\nrequestData1().then(result1 =\u0026gt; { requestData2(result2 =\u0026gt; { .... }); }); This is not readable, so let\u0026rsquo;s refactor it as in the following code.\nRefactored code to avoid nesting: requestData1() .then(result1 =\u0026gt; { return requestData2(result1) }) .then(result2 =\u0026gt; { return ... // 1번 }) If you need to reference the result1 variable in the first instance, how can you do that?\nYou can solve the variable reference issue without nesting by using Promise.all.\nCode solving variable reference problem using Promise.all:\nrequestData1() .then(result1 =\u0026gt; { return Promise.all([result1, requestData2(result1)]) // 1 .then(([result1, result2]) =\u0026gt; { ........... }); In the first instance, if you input non-promise values into the array for the Promise.all function, those values will be treated as if they are fulfilled promises.\nPay Attention to Exception Handling in Synchronous Code\nWhen using promises like synchronous (sync) code, you should pay attention to exception handling.\nCode where exceptions occurring in synchronous code are not handled: function requestData() { doSync() // 1 return fetch() .then((data) =\u0026gt; console.log(data)) .catch((error) =\u0026gt; console.log(error)) } In the first instance, if the doSync function does not necessarily need to be called before fetch, it\u0026rsquo;s better to put it inside the then method like this:\nCode where synchronous code also handles exceptions: function requestData() { return fetch() .then((data) =\u0026gt; { doSync() console.log(data) }) .catch((error) =\u0026gt; console.log(Error)) } Exceptions occurring in doSync will be handled by the catch method.\nEnhanced Asynchronous Programming: async, await\nUnderstanding async/await:\nWhile promises exist as objects, async/await is a concept applied to functions.\nA function returning a promise using async/await:\nasync function getData() { return 123 //Promise {\u0026lt;fulfilled\u0026gt;: 123} } getData().then((data) =\u0026gt; console.log(data)) // 123 Promise {\u0026lt;fulfilled\u0026gt;: undefined} A function returning a promise using async/await: async function getData() { return Promise.resolve(123) } getData().then((data) =\u0026gt; console.log(data)) Similar to the then method of promises, if the value returned within the async/await function is a promise, that object will be returned as is.\nCases where exceptions occur in async/await functions: async function getData() { throw new Error(\u0026#39;123\u0026#39;) } getData().catch((error) =\u0026gt; console.log(error)) // Error : 123 Using the await keyword: function requestData(value) { return new Promise((resolve) =\u0026gt; setTimeout(() =\u0026gt; { console.log(\u0026#39;requestData:\u0026#39;, value) resolve(value) }, 100) ) } async function getData() { const data1 = await requestData(10) //1 const data2 = await requestData(20) //1 console.log(data1, data2) // 2 return [data1, data2] } getData() // requestData: 10 // 3 // requestData: 20 // 3 // 10, 20 // 3 In the first instance, the code in the second instance will not execute until the promise returned by requestData is fulfilled. Therefore, the result of calling the getData function is reflected in the third instance.\nThe async keyword can only be used within async/await functions. Using it in a regular function will cause an error.\nawait 키워드는 async 키워드 없이 사용 할 수 없다. function getData(){ const data = await requestData(10); // Error console.log(data); } async/await is more readable than promises.\nComparing async/await and Promises function getDataPromise() { asyncFunc1() .then((data) =\u0026gt; { console.log(data) return asyncFunc2() }) .then((data) =\u0026gt; { console.log(data) }) } // 1번 프로미스로 작성한 코드 async function getDataAsync() { const data1 = await asyncFunc1() console.log(data1) const data2 = await asyncFunc2() console.log(data2) } // 2번 async await로 작성한 코드 The code written using async/await has better readability. The reason for its conciseness is that async/await functions do not require calling the then method.\nComparing Readability in Highly Dependent Code function getDataPromise() { return asyncFunc1() .then(data1 =\u0026gt; Promise.all([data1, asyncFunc2(data1)])) // 1 .then([data1, data2]) =\u0026gt; { return asyncFunc3(data1,data2); }); } async function getDataAsync() { // 2 const1 data1 = await asyncFunc1(); const2 data2 = await asyncFunc2(data1); return asyncFunc3(data1, data2); } In 1, Promise.all is used to pass two return values to the asyncFunc3 function. In 2, the async/await function remains intuitive even with complex dependencies.\nUsing async/await Effectively\nRunning Asynchronous Functions in Parallel Sequentially running asynchronous code async function getData() { const data1 = await asyncFunc1() const data2 = await asyncFunc2() // ... } If there are no dependencies between the two functions, it is better to run them simultaneously. Promises execute asynchronously as soon as they are created. Therefore, by creating two promises first and using the await keyword later, we can achieve parallel execution.\nRunning Asynchronous Code in Parallel by Using await Later async function getData() { const p1 = asyncFunc1() const p2 = asyncFunc2() const data1 = await p1 const data2 = await p2 } Using Promise.all to Process in Parallel async function getData() { const [data1, data2] = await Promise.all([asyncFunc1(), asyncFunc2()]) // .... } Handling Exceptions It is advisable to handle exceptions occurring within async/await functions using try/catch blocks. Both synchronous and asynchronous functions can be handled in the catch block. async function getData() { try { await doAsync() return doSync() } catch (error) { console.log(error) } } All exceptions that occur in asynchronous and synchronous functions are handled in the catch block.\nSupport for Thenables in async/await Thenables are objects that behave like promises.\nExample of Using Thenables in async/await Functions class ThenableExample { then(resolve, reject) { // 1번 setTimeout(() =\u0026gt; resolve(123), 1000) } } async function asyncFunc() { const result = await new ThenableExaple() // 2번 console.log(result) // 123 } In 1, the ThenableExample class has a then method, so any object created from the ThenableExample class is considered a Thenable. In 2, the async/await function treats Thenables like promises.\nDifference Between sync/await and Promises Promise: Ignores the execution of the code when it is encountered and continues executing the next code. async/await: When it encounters await, it waits until the code is finished (until the request is completed, until it is not pending) before executing the next code. ","permalink":"https://findmytrueself.github.io/en/frontend/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%97%90%EC%84%9C%EC%9D%98-%EB%B9%84%EB%8F%99%EA%B8%B0%EC%B2%98%EB%A6%AC/","tags":["Javascript"],"title":"Asynchronous Processing in JavaScript"},{"categories":null,"content":"Components of a Web Browser\nCall Stack: A stack that holds functions to be executed sequentially in JavaScript. Web API: APIs provided by the web browser for performing asynchronous tasks, such as AJAX and setTimeout. Task Queue: Also known as the Callback Queue, it stores callback functions passed from the Web API. Event Loop: Checks if the Call Stack is empty; if it is, it moves tasks from the Task Queue to the Call Stack. setTimeout(() =\u0026gt; console.log(\u0026#34;Async Hi hun\u0026#34;)); console.log(\u0026#34;Hello! World\u0026#34;); // Hello! World // Async Hi hun Even though asynchronous code is executed first, we can see it printed later.\nThe setTimeout function is executed and added to the Call Stack. The setTimeout function is not handled by the JavaScript engine but by the Web API (in the case of Node.js, the Timers module). Once the timeout duration has passed, the Web API passes the callback function to the Task Queue. Next, the console.log on the second line is added to the Call Stack. The console.log in the Call Stack is executed immediately, and the string \u0026ldquo;Hello! World\u0026rdquo; is printed to the console. At this point, the JavaScript Event Loop constantly checks if the Call Stack is empty. After executing console.log, the Event Loop confirms that the Call Stack is empty. Once the Event Loop detects that the Call Stack is empty, it moves the callback function from the Task Queue to the Call Stack to execute it. The string \u0026ldquo;Async Hi Hun\u0026rdquo; is then printed. Once all tasks are completed, both the Call Stack and Task Queue are empty.\n","permalink":"https://findmytrueself.github.io/en/frontend/%EC%9B%B9%EC%84%9C%EB%B9%84%EC%8A%A4%EA%B0%80-%EB%8F%99%EC%9E%91%ED%95%98%EA%B2%8C-%ED%95%98%EB%8A%94-%EA%B8%B0%EB%B3%B8-%ED%94%8C%EB%A1%9C%EC%9A%B0/","tags":["Javascript","Web"],"title":"Basic Flow of How Web Services Operate"}]